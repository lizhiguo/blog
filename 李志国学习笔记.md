







# JAVA

## SpringBoot

### jackson

### WebFilter

> ```
> @Order(2)值越小优先级越高，先执行LoggingWebFilter过滤器，在执行DecryptRequestFilter过滤器
> ```

#### LoggingWebFilter

```
@Order(2)
@Component
class LoggingWebFilter : WebFilter {
    companion object {
        const val REQUEST_ID = "requestId"
    }
    @Autowired
    lateinit var log: Logger
    override fun filter(exchange: ServerWebExchange, chain: WebFilterChain): Mono<Void> {
        val uniqueId = UUID.randomUUID()
        MDC.put(REQUEST_ID, uniqueId.toString()) //跟踪id
        exchange.response.headers.add(REQUEST_ID, uniqueId.toString())
        return chain.also {
            val beginTime = System.currentTimeMillis()
            exchange.attributes.put("beginTime", beginTime) //开始时间 或者exchange.attributes["beginTime"] = beginTime
            log.debug("----请求开始--[${beginTime}]-------")
        }.filter(LoggingWebExchange(log, exchange)).then(Mono.fromRunnable<Void> {
            log.debug(
                "-------网关请求结束:耗时[{}]-------",
                System.currentTimeMillis() - exchange.attributes.get("beginTime") as Long
            )
        })
    }
}
```

#### DecryptRequestFilter

```
@Order(3)
@Component
class DecryptRequestFilter : WebFilter {
    companion object {
        val log: Logger = LoggerFactory.getLogger(DecryptRequestFilter::class.java)
    }
    override fun filter(exchange: ServerWebExchange, chain: WebFilterChain): Mono<Void> {
        println("----DecryptRequestFilter----")
        val requestResponseExchange = DecryptRequestExchange(exchange)
        return chain.filter(requestResponseExchange).then(Mono.fromRunnable<Void> {
            println("--------DecryptRequestFilter end----")
        })
    }

    class DecryptRequestExchange(exchange: ServerWebExchange) : ServerWebExchangeDecorator(exchange) {
        override fun getRequest(): DecryptRequestDecorator = DecryptRequestDecorator(super.getRequest())
    }

    class DecryptRequestDecorator(delegate: ServerHttpRequest) : ServerHttpRequestDecorator(delegate) {

        private var decryptBuffer : ByteArray? = null

        override fun getBody(): Flux<DataBuffer> {
            return super.getBody().flatMap {
                decryptBuffer = AESUtils.decrypt(StandardCharsets.UTF_8.decode(it.asByteBuffer()).toString())
                Flux.just(DefaultDataBufferFactory().wrap(ByteBuffer.wrap(decryptBuffer)))
            }
        }
    }
}
```

#### MDC

##### logback

> 对应LoggingWebFilter过滤器打印tackid

```
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <appender name="Console" class="ch.qos.logback.core.ConsoleAppender">
        <!--<encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
            </pattern>
        </encoder>-->
        <layout class="ch.qos.logback.classic.PatternLayout">
            <pattern>
                %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [%X{requestId}] %file -> %M\(%line\) - %msg%n
            </pattern>
        </layout>
    </appender>

    <root level="debug">
        <appender-ref ref="Console" />
    </root>
</configuration>
```

### 消息队列Stream

#### rabbit

>在使用stream 整合rabbitMQ的时候 突然发现新版本不建议使用@Binding(Source.class) 、@StreamListener(Sink.class)查看了 [官方文档][https://docs.spring.io/spring-cloud-stream/docs/3.1.0/reference/html/spring-cloud-stream.html#spring_cloud_function],和一些网站 摸索了一会发现了这个新的写法，使用java.util.function.[Supplier/Function/Consumer]的方式下面通过代码来细说：有些需要注意的地方在代码下方单独提出来了

##### 配置jar

```
<dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-stream-rabbit</artifactId>
</dependency>
# 或者
implementation("org.springframework.cloud:spring-cloud-starter-stream-rabbit:4.0.2")
```

###### 生产者

1. 配置

	```
	server:
	  port: 8801
	spring:
	  application:
	    name: cloud-stream-privider #端口和微服务名称 老两样
	#中间cloud部分和8802一样
	  cloud:
	    stream:
	      binders:   #自此处配置要绑定的rabbitmq的服务信息
	        defaultRabbit: #表示定义的名称，用于binding整合
	          type: rabbit #消息组件类型
	          environment:  # 设置rabbitmq的相关的环境配置 stream3.1只需要配置这些即可
	            spring:
	              rabbitmq:
	                host: localhost
	                port: 5672  #mq调用的端口为5672
	                username: guest
	                password: guest
	```

2. 生产者代码

```
# 接口--service----
public interface IMessage {
    void sendMethod();
}
# 实现---serviceImpl---
import com.peach.springcloud.service.IMessage;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.function.StreamBridge;
import org.springframework.stereotype.Component;

import java.util.UUID;

@Component
public class MessageProviderImpl implements IMessage {
    //这里直接装配一个桥 用来连接rabbit或者kafka
    @Autowired
    StreamBridge streamBridge;
    @Override
    public void sendMethod() {
        String message = UUID.randomUUID().toString();
        //这里说明一下这个 streamBridge.send 方法的参数 第一个参数是exchange或者topic 就是主题名称
        //默认的主题名称是通过
        //输入:    <方法名> + -in- + <index>
        //输出:    <方法名> + -out- + <index>
        //这里我们接收的时候就要用send方法 参数是consumer<String>接收  详情看8802的controller
        //consumer的参数类型是这里message的类型
        streamBridge.send("send-in-0", message);
        System.out.println("************发送了message："+message);
    }
}
#  --------controller----
@RestController
public class SendMessageController {

    @Resource
    private MessageProviderImpl messageProvider;

    @RequestMapping("/send")
    public void send(){
        messageProvider.sendMethod();
    }
}
```

###### 消费者

1. 配置

	```
	  server:
	    port: 8802
	  spring:
	    application:
	      name: cloud-stream-privider
	      
	#中间cloud部分和8802一样
	  cloud:
	    stream:
	      binders:   #自此处配置要绑定的rabbitmq的服务信息
	        defaultRabbit: #表示定义的名称，用于binding整合
	          type: rabbit #消息组件类型
	          environment:  # 设置rabbitmq的相关的环境配置 stream3.1只需要配置这些即可
	            spring:
	              rabbitmq:
	                host: localhost
	                port: 5672  #mq调用的端口为5672
	                username: guest
	                password: guest
	  eureka:
	    client:
	      service-url:
	        defaultZone: http://localhost:7001/eureka/
	    instance:
	      lease-expiration-duration-in-seconds: 5 #如果现在超过了5秒的间隔
	      lease-renewal-interval-in-seconds: 2 #设置心跳的时间间隔
	      instance-id: send-8802.com
	      prefer-ip-address: true #访问的路径变为IP地址
	```

2. 代码

	```
	# controller
	import java.util.function.Consumer;
	
	@Component
	public class ReceiveMessageController {
	
	    @Value("${server.port}")
	    private String serverPort;
	
	    @Bean
	    //这里接收rabbitmq的条件是参数为Consumer 并且 方法名和supplier方法名相同
	    //这里的返回值是一个匿名函数 返回类型是consumer 类型和提供者的类型一致
	    //supplier发送的exchange是 send-in-0 这里只需要用send方法名即可
	    Consumer<String> send() {
	        return str -> {
	            System.out.println("我是消费者"+serverPort+"，我收到了消息："+str);
	        };
	    }
	}
	```

### Springboot-jpa

##### Junit

> hello

###### Kjpa

## MapStruct

> 参考地址：https://blog.csdn.net/qq_43437874/category_11751054.html

### 注解汇总大全

#### @Mapper

> `@Mapper`将接口或抽象类标记为映射器，并自动生成映射实现类代码。

```
public @interface Mapper {
	// 引入其他其他映射器
    Class<?>[] uses() default {};
	// 将类import 到生成的实现类中
	// 可以使用 {@link mapping#expression（）}表达式中引用这些类型，{@link Mapping#defaultExpression（）}使用他们简单的名字，而不是完全限定的名字。
    Class<?>[] imports() default {};
	// 源类型未被映射时的策略，默认忽略
    ReportingPolicy unmappedSourcePolicy() default ReportingPolicy.IGNORE;
	// 目标类型未被映射时的策略，默认警告
    ReportingPolicy unmappedTargetPolicy() default ReportingPolicy.WARN;
	// 转换存在精度损失的的策略
    ReportingPolicy typeConversionPolicy() default ReportingPolicy.IGNORE;
	// 指定生成的映射器应该使用的组件模型，比如Spring bean、CDI等
    String componentModel() default "default";
	// 指定实现类的名称。默认加上Impl 后缀
    String implementationName() default "<CLASS_NAME>Impl";
	//  指定生成实现类的包名。默认当前包
    String implementationPackage() default "<PACKAGE_NAME>";
	// 引入一个用 {@link MapperConfig} 注解的配置
    Class<?> config() default void.class;
	// 集合类型属性的值时应用的策略。
    CollectionMappingStrategy collectionMappingStrategy() default CollectionMappingStrategy.ACCESSOR_ONLY;
	// 当 {@code null} 作为源参数值传递给此映射器的方法时要应用的策略。
    NullValueMappingStrategy nullValueMappingStrategy() default NullValueMappingStrategy.RETURN_NULL;
	// 当 {@code null} 作为源参数值传递给 {@link IterableMapping} 时应用的策略
    NullValueMappingStrategy nullValueIterableMappingStrategy() default 	 NullValueMappingStrategy.RETURN_NULL;
	//  当 {@code null} 作为源参数值传递给 {@link MapMapping} 时应用的策略
    NullValueMappingStrategy nullValueMapMappingStrategy() default NullValueMappingStrategy.RETURN_NULL;
	// 当源属性为 {@code null} 或不存在时应用的策略。
    NullValuePropertyMappingStrategy nullValuePropertyMappingStrategy() default NullValuePropertyMappingStrategy.SET_TO_NULL;
	//  用于在接口中应用原型方法的方法级配置注解的策略
    MappingInheritanceStrategy mappingInheritanceStrategy() default MappingInheritanceStrategy.EXPLICIT;
	// 确定何时对 bean 映射的源属性值进行空检查。
    NullValueCheckStrategy nullValueCheckStrategy() default NullValueCheckStrategy.ON_IMPLICIT_CONVERSION;
	// 确定在使用 {@link SubclassMapping} 时如何处理超类的缺失实现。
    SubclassExhaustiveStrategy subclassExhaustiveStrategy() default SubclassExhaustiveStrategy.COMPILE_ERROR;
	//  确定是使用字段注入还是构造函数注入
    InjectionStrategy injectionStrategy() default InjectionStrategy.FIELD;
	// 是否禁用自动生成子映射方法
    boolean disableSubMappingMethodsGeneration() default false;
	// 构建器信息
    Builder builder() default @Builder;
	// 允许详细控制映射过程。
    Class<? extends Annotation> mappingControl() default MappingControl.class;
	// 如果没有与枚举匹配的映射，则生成的代码应抛出异常。
    Class<? extends Exception> unexpectedValueMappingException() default IllegalArgumentException.class;
	// 指示是否应禁止在 {@code @Generated} 注释中添加时间戳的标志。
    boolean suppressTimestampInGenerated() default false;
}
```

#### @Mapping

> `@Mapping`用于配置属性或枚举常量的映射关系。

```
public @interface Mapping {
	// JavaBeans 规范定义的目标帝乡配置属性的名称
    String target();
	// 用于此映射的源
    String source() default "";
	// 可被 {@link SimpleDateFormat} 处理的日期格式字符串。
    String dateFormat() default "";
	//  可被 {@link DecimalFormat} 处理的十进制格式字符串。
    String numberFormat() default "";
	// 一个常量 {@link String} 将基于它来设置指定的目标属性。
    String constant() default "";
	// 一个表达式 {@link String} 将基于它来设置指定的目标属性。
    String expression() default "";
	// 一个 defaultExpression {@link String}，基于它来设置指定的目标属性， 当且仅当指定的源属性为空时。
    String defaultExpression() default "";
	// 通过 {@link #target()} 指定的属性是否应该被生成的映射方法忽略。
    boolean ignore() default false;
	// 可以指定限定符以帮助选择合适的映射器。
    Class<? extends Annotation>[] qualifiedBy() default {};
	// 一个或多个限定符名称
    String[] qualifiedByName() default {};
	// 指定在多个映射方法符合条件时要使用的映射方法的结果类型。
    Class<?> resultType() default void.class;
	// 映射属性的依赖关系
    String[] dependsOn() default {};
	// 在源属性为 {@code null} 的情况下设置的默认值。
    String defaultValue() default "";
	// 确定何时对 bean 映射的源属性值进行空检查。
    NullValueCheckStrategy nullValueCheckStrategy() default NullValueCheckStrategy.ON_IMPLICIT_CONVERSION;
	//  {@code null} 作为源属性值或源属性传递时应用的策略
    NullValuePropertyMappingStrategy nullValuePropertyMappingStrategy() default NullValuePropertyMappingStrategy.SET_TO_NULL;
}
```

#### @Mappings

> `@Mappings `用于声明多个`@Mapping`。

```
public @interface Mappings {
    Mapping[] value();
}
```

#### @BeforeMapping @AfterMapping

>`@BeforeMapping`和`@AfterMapping `标记在映射方法开始或结束后时需要调用的方法，也就是可以在映射开始、结束后调用。可以在映射前后做一些自定义操作，类似AOP中的[切面](https://so.csdn.net/so/search?q=切面&spm=1001.2101.3001.7020)。

#### @BeanMapping

> `@BeanMapping`配置两种bean类型之间的映射。

```
public @interface BeanMapping {
	//  指定在多个工厂方法符合条件时使用的工厂方法的结果类型，
    Class<?> resultType() default void.class;
	// 指定限定符以帮助选择合适的工厂方法
    Class<? extends Annotation>[] qualifiedBy() default {};
	// 使用限定符名称查找
    String[] qualifiedByName() default {};
	// 当 {@code null} 作为源值传递给此映射的方法时要应用的策略。
    NullValueMappingStrategy nullValueMappingStrategy() default NullValueMappingStrategy.RETURN_NULL;
	// {@code null} 作为源属性值或源属性传递时应用的策略
    NullValuePropertyMappingStrategy nullValuePropertyMappingStrategy() default NullValuePropertyMappingStrategy.SET_TO_NULL;
	// 如何做空检查策略
    NullValueCheckStrategy nullValueCheckStrategy() default NullValueCheckStrategy.ON_IMPLICIT_CONVERSION;
	// 确定在使用 {@link SubclassMapping} 时如何处理超类缺失。
    SubclassExhaustiveStrategy subclassExhaustiveStrategy() default SubclassExhaustiveStrategy.COMPILE_ERROR;
	// 默认忽略所有映射。所有映射都必须手动定义。不会发生自动映射。
    boolean ignoreByDefault() default false;
	// 未映射的源属性将被忽略。
    String[] ignoreUnmappedSourceProperties() default {};
	// 如何报告映射的目标类型的未映射属性。
    ReportingPolicy unmappedTargetPolicy() default ReportingPolicy.WARN;
	// 指定构建者
    Builder builder() default @Builder;
	//  允许详细控制映射过程。
    Class<? extends Annotation> mappingControl() default MappingControl.class;
}
```

#### @InheritConfiguration @InheritInverseConfiguration

> `inherit`是继承的意思，`Inverse`是反转的意思。
>
> `@InheritConfiguration `可以继承其他映射方法上的配置（@Mapping、@IterableMapping 、 Mapper#config()等方式上的配置）。

```
public @interface InheritConfiguration {

    /**
     * 要从中继承映射的映射方法的名称
     */
    String name() default "";
}
```

> `@InheritInverseConfiguration`是反向隐射继承，也就是对继承的配置进行逆向映射。

```
public @interface InheritInverseConfiguration{

    /**
     * 要从中继承映射的映射方法的名称
     */
    String name() default "";
}
```

#### @IterableMapping

> `@IterableMapping`用于配置两个几个类似类型之间的映射，例如` {@code List<String>}` 和 `{@code List<Date>}`。

```
public @interface IterableMapping {
	// 可被 {@link SimpleDateFormat} 处理的日期格式字符串。
    String dateFormat() default "";
	// 可被 {@link DecimalFormat} 处理的十进制格式字符串。
    String numberFormat() default "";
	// 可以指定限定符以帮助选择合适的映射器。
    Class<? extends Annotation>[] qualifiedBy() default {};
	// 一个或多个限定符名称
    String[] qualifiedByName() default {};
	// 指定要在映射方法的结果中使用的元素的类型，以防多重映射方法符合条件。
    Class<?> elementTargetType() default void.class;
	//  当 {@code null} 作为源值传递给此可迭代映射时要应用的策略。
    NullValueMappingStrategy nullValueMappingStrategy() default NullValueMappingStrategy.RETURN_NULL;
	// 允许详细控制映射过程
    Class<? extends Annotation> elementMappingControl() default MappingControl.class;
}
```

#### @ValueMapping @ValueMappings

> `@ValueMapping `配置源常量值到目标常量值的映射，支持枚举到枚举，`@ValueMappings`就是可以写多个`@ValueMapping `。

```
public @interface ValueMapping {
    String source();

    String target();
}
public @interface ValueMappings {
    ValueMapping[] value();
}
```

#### @SubclassMapping @SubclassMappings

> `@ValueMapping `配置映射子类，也就是参数和目标对象为父类时，执行其子类的映射关系，`@SubclassMappings`就是可以写多个`@SubclassMapping`。

```
public @interface SubclassMapping {
	//  要映射的子类
    Class<?> source();
	// 要映射到的子类
    Class<?> target();
}
public @interface SubclassMappings {
    SubclassMapping[] value();
}
```

#### @TargetType

> `@TargetType`可以在自定义映射方法的参数中声明目标对象的类型。比如返回类型为泛型，这个时候可以在参数中指定目标的类型。不能将多个参数声明为`{@code TargetType}`,并且该参数必须是`{@link Class}`类型或者它的超类型。

```
public class EntityFactory {
public <T extends BaseEntity> T createEntity(@TargetType Class entityClass) {
 	return // ... custom factory logic
  }
 }
```

#### @Named

> `@Named`可以给映射方法取名，然后通过限定符直接使用名称绑定映射方法。

```
public @interface Named {
	// 限定注解元素的名称
    String value();
}
```

#### @MapperConfig

> 将类或接口标记为配置，允许在多个映射器类之间共享通用配置。

```
public @interface MapperConfig {
	// 使用其他的映射器
    Class<?>[] uses() default {};
	// 将类import 到生成的实现类中
	// 可以使用 {@link mapping#expression（）}表达式中引用这些类型，{@link Mapping#defaultExpression（）}使用他们简单的名字，而不是完全限定的名字。
    Class<?>[] imports() default {};
	// 映射的源类型的存在未映射属性应该如何报告
    ReportingPolicy unmappedSourcePolicy() default ReportingPolicy.IGNORE;
	// 映射的目标类型存在未映射属性应该如何映射
    ReportingPolicy unmappedTargetPolicy() default ReportingPolicy.WARN;
	// 存在精度损失，如何报告
    ReportingPolicy typeConversionPolicy() default ReportingPolicy.IGNORE;
	// 映射器组件模型
    String componentModel() default "default";
	// 指定实现类的名称。默认后缀为Impl
    String implementationName() default "<CLASS_NAME>Impl";
	// 指定包名
    String implementationPackage() default "<PACKAGE_NAME>";
	// 集合类型属性的值时应用的策略。
    CollectionMappingStrategy collectionMappingStrategy() default CollectionMappingStrategy.ACCESSOR_ONLY;
	// 当 {@code null} 作为源参数值传递给此映射器的方法时要应用的策略。
    NullValueMappingStrategy nullValueMappingStrategy() default NullValueMappingStrategy.RETURN_NULL;
	// 当 {@code null} 作为源参数值传递给 {@link IterableMapping} 时应用的策略
    NullValueMappingStrategy nullValueIterableMappingStrategy() default NullValueMappingStrategy.RETURN_NULL;
	//  当 {@code null} 作为源参数值传递给 {@link MapMapping} 时应用的策略
    NullValueMappingStrategy nullValueMapMappingStrategy() default NullValueMappingStrategy.RETURN_NULL;
	// 当源属性为 {@code null} 或不存在时应用的策略。
    NullValuePropertyMappingStrategy nullValuePropertyMappingStrategy() default NullValuePropertyMappingStrategy.SET_TO_NULL;
	//  用于在接口中应用原型方法的方法级配置注解的策略
    MappingInheritanceStrategy mappingInheritanceStrategy() default MappingInheritanceStrategy.EXPLICIT;
	// 确定何时对 bean 映射的源属性值进行空检查。
    NullValueCheckStrategy nullValueCheckStrategy() default NullValueCheckStrategy.ON_IMPLICIT_CONVERSION;
	// 确定在使用 {@link SubclassMapping} 时如何处理超类的缺失实现。
    SubclassExhaustiveStrategy subclassExhaustiveStrategy() default SubclassExhaustiveStrategy.COMPILE_ERROR;
	//  确定是使用字段注入还是构造函数注入
    InjectionStrategy injectionStrategy() default InjectionStrategy.FIELD;
    // 是否禁用自动生成子映射方法
    boolean disableSubMappingMethodsGeneration() default false;
	// 构建器信息
    Builder builder() default @Builder;
	// 允许详细控制映射过程。
    Class<? extends Annotation> mappingControl() default MappingControl.class;
	// 如果没有与枚举匹配的映射，则生成的代码应抛出异常。
    Class<? extends Exception> unexpectedValueMappingException() default IllegalArgumentException.class;
	// 指示是否应禁止在 {@code @Generated} 注释中添加时间戳的标志。
    boolean suppressTimestampInGenerated() default false;
}
```

#### @EnumMapping

> `@EnumMapping` 配置两种[枚举类型](https://so.csdn.net/so/search?q=枚举类型&spm=1001.2101.3001.7020)之间的映射。

```
public @interface EnumMapping {
	// 指定应该用于枚举之间的隐式映射的名称转换策略。
    String nameTransformationStrategy() default "";
	// 应该在适当的名称转换策略上传递的配置。
    String configuration() default "";
	// 应该在生成的代码中使用的异常
    Class<? extends Exception> unexpectedValueMappingException() default IllegalArgumentException.class;
}
```

#### @DecoratedWith

> `Decorated`是装饰的意思，` @DecoratedWith`指定要应用于生成的映射器的装饰器。

```
public @interface DecoratedWith {
	// 装饰器类型。必须是一个抽象类。
    Class<?> value();
}
```

#### @Context

> 将方法的参数标记为映射上下文。此类参数传递给其他映射方法。

#### @Condition

> `@Condition`将方法标记为检查方法，以检查 bean 中的属性是否存在等检查。检查方法必须返回` {@code boolean}`。

```
public class PresenceCheckUtils {
 
    @Condition
    public static boolean isNotEmpty(String value) {
       return value != null && !value.isEmpty();
    }
  }
```

#### @DeepClone

> 将源类型克隆到目标类型（假设源和目标属于同一类型）。

#### @MappingControl @MappingControls

> `@MappingControl `控制源和目标之间的映射方式。

```
@Retention(RetentionPolicy.CLASS)
@Repeatable(MappingControls.class)
@Target({ElementType.ANNOTATION_TYPE})
@MappingControls({@MappingControl(MappingControl.Use.DIRECT), @MappingControl(MappingControl.Use.BUILT_IN_CONVERSION), @MappingControl(MappingControl.Use.MAPPING_METHOD), @MappingControl(MappingControl.Use.COMPLEX_MAPPING)})
public @interface MappingControl {
    MappingControl.Use value();

    public static enum Use {
    	   /**
         * 控制映射，允许从源类型到目标类型的类型转换
         * <p>
         * Java 通常直接支持类型转换。“toString()”就是这样一个例子，
         * 它允许将例如 {@link java.lang.Number} 类型映射到 {@link java.lang.String}。
         * <p>
         * 请参阅 MapStruct 指南了解更多信息。
         *
         * @从 1.4 开始
         */
        BUILT_IN_CONVERSION,
          /**
         * 控制从源类型到目标类型的映射，允许通过调用进行映射：
         * <ol>
         * <li>类型转换，传入映射方法</li>
         * <li>映射方法，传入类型转换</li>
         * <li>一个映射方法传入另一个映射方法</li>
         * </ol>
         *
         * @从 1.4 开始
         */
        COMPLEX_MAPPING,
        // 如果源类型和目标类型是相同的类型，MapStruct 将不会执行不再有任何映射，并将目标直接分配给源。
        // 一个例外是来自包 {@code java} 的类型，它们将始终直接映射。
        DIRECT,
        // 映射方法可以是自定义引用的映射方法，也可以是内置的 MapStruct映射方法。
        MAPPING_METHOD;

        private Use() {
        }
    }
}
```

#### @NoComplexMapping

> 禁用复杂映射，必须使用方法或内置转换方式构成的映射。

### 使用例子

```
/**
 * dto和entity互转
 */
interface BaseDEMapper<D, E>{
    fun toEntity(dto : D) : E
    fun toDto(entity : E) : D
    fun toEntity(ds : List<D>) : List<E>
    fun toDto(es : List<E>) : List<D>
}

/**
 * vo和entity转换
 */
interface BaseVEMapper<V, E>{
    fun votoEntity(vo : V) : E
}
/**************************************************************************************/
@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
abstract class DictDataMapper : BaseDEMapper<DictDataDto, DictData>,BaseVEMapper<DictDataVo, DictData>{
    companion object {
        var INSTANCE: DictDataMapper = Mappers.getMapper(DictDataMapper::class.java)
    }
    @Autowired
    private lateinit var dictTypeRepository: DictTypeRepository
    @Mappings(
        Mapping(source = "dictTypeCode", target = "dictType", qualifiedByName = ["getDictType"]),
    )
    abstract fun fromVoToEntity(entity: DictDataVo): DictData

    @Named("getDictType")
    fun getDictType(dictTypeCode: String): DictType {
        return dictTypeRepository.findByDictType(dictTypeCode)
    }

    @Mappings(
        Mapping(source = "dictType.dictType", target = "dictTypeCode"),
    )
    override abstract fun toDto(entity: DictData): DictDataDto

    override abstract fun toDto(entity: List<DictData>): List<DictDataDto>
}
/************************使用*************************/
@Test
fun `数据查询2`() {
	val dictType = "zncd_scene"
	var res =queryFactory.listQuery<DictData>{
			select(entity(DictData::class))
			from(entity(DictData::class))
			fetch(DictData::dictType)
			where(col(DictType::dictType).equal(dictType))
		}?.let {
			DictDataMapper.INSTANCE.toDto(it)
		}
	println(JSONUtil.toJsonPrettyStr(res))
}
```



# Kotlin

## Kotlin 常用技巧

### 对象

#### data类

> 和一般对应一样使用

```
@JsonInclude(JsonInclude.Include.NON_EMPTY)
data class Book(var title: String, @JsonProperty("author") var authorName: String) {
    var genres: List<String>? = emptyList()
}
```

#### jackson

> 动态序列化
>
> https://github.com/ksprider/Surgical/tree/master
>
> https://github.com/shihyuho/jackson-dynamic-filter/tree/master
>
> https://github.com/shihyuho/jackson-dynamic-filter-spring-boot-starter

```
# 数据类
@JsonFilter("movie")
data class Movie(var name: String, var studio: String, var rating: Float? = 1f)
#测试类
class JacksonUnitTest {
    private val mapper = ObjectMapper().registerModule(
        KotlinModule.Builder()
            .withReflectionCacheSize(512)
            .configure(KotlinFeature.NullToEmptyCollection, false)
            .configure(KotlinFeature.NullToEmptyMap, false)
            .configure(KotlinFeature.NullIsSameAsDefault, false)
            .configure(KotlinFeature.SingletonSupport, false)
            .configure(KotlinFeature.StrictNullChecks, false)
            .build()
    ).enable(SerializationFeature.INDENT_OUTPUT) // 应用缩进, 增强可读性
    @Test
    fun `动态序列化字段_使用JsonFilter`() {
    	val movie =  Movie("Endgame", "Marvel", 9.2f)
    	val json = mapper.apply {
    		setFilterProvider(SimpleFilterProvider().addFilter("movie", 	//这个名字对应@JsonFilter("movie")	SimpleBeanPropertyFilter.filterOutAllExcept("name","studio")))
    		}.writeValueAsString(movie)
    println(json) //{"name":"Endgame","studio":"Marvel"}
    }
    fun `节点数据`() {
        val jsonString = """
            {"k1":"v1","k2":"v2"}
        """.trimIndent()
        val jsonNode = mapper.readTree(jsonString) //JsonNode,tree模型专用
        println(jsonNode.get("k1"))
    }
```



### 作用域函数

Kotlin 标准库包含几个函数，它们的唯一目的是在对象的上下文中执行代码块。当对一个对象调用这样的函数并提供一个 [lambda 表达式](https://www.kotlincn.net/docs/reference/lambdas.html)时，它会形成一个临时作用域。在此作用域中，可以访问该对象而无需其名称。这些函数称为*作用域函数*。共有以下五种：`let`、`run`、`with`、`apply` 以及 `also`。

参考：https://www.kotlincn.net/docs/reference/scope-functions.html

##### 函数选择

| **函数** | **对象引用** | **返回值**        | **是否是扩展函数**         |
| -------- | ------------ | ----------------- | -------------------------- |
| let      | it           | Lambda 表达式结果 | 是                         |
| run      | this         | Lambda 表达式结果 | 是                         |
| run      | -            | Lambda 表达式结果 | 不是：调用无需上下文对象   |
| with     | this         | Lambda 表达式结果 | 不是：把上下文对象当做参数 |
| apply    | this         | 上下文对象        | 是                         |
| also     | it           | 上下文对象        | 是                         |

以下是根据预期目的选择作用域函数的简短指南：

* 对一个非空（non-null）对象执行 lambda 表达式：`let`
* 将表达式作为变量引入为局部作用域中：`let`
* 对象配置：`apply`
* 对象配置并且计算结果：`run`
* 在需要表达式的地方运行语句：非扩展的 `run`
* 附加效果：`also`
* 一个对象的一组函数调用：`with`

##### 区别

> 由于作用域函数本质上都非常相似，因此了解它们之间的区别很重要。每个作用域函数之间有两个主要区别：

* 引用上下文对象的方式
* 返回值

##### 上下文对象：`this` 还是 `it`

在作用域函数的 lambda 表达式里，上下文对象可以不使用其实际名称而是使用一个更简短的引用来访问。每个作用域函数都使用以下两种方式之一来访问上下文对象：作为 lambda 表达式的[接收者](https://www.kotlincn.net/docs/reference/lambdas.html#带有接收者的函数字面值)（`this`）或者作为 lambda 表达式的参数（`it`）。两者都提供了同样的功能，因此我们将针对不同的场景描述两者的优缺点，并提供使用建议。

```
fun main() {
    val str = "Hello"
    // this
    str.run {
        println("The receiver string length: $length")
        //println("The receiver string length: ${this.length}") // 和上句效果相同
    }

    // it
    str.let {
        println("The receiver string's length is ${it.length}")
    }
}
```

###### this

`run`、`with` 以及 `apply` 通过关键字 `this` 引用上下文对象。因此，在它们的 lambda 表达式中可以像在普通的类函数中一样访问上下文对象。在大多数场景，当你访问接收者对象时你可以省略 `this`，来让你的代码更简短。相对地，如果省略了 `this`，就很难区分接收者对象的成员及外部对象或函数。因此，对于主要对对象成员进行操作（调用其函数或赋值其属性）的 lambda 表达式，建议将上下文对象作为接收者（`this`）。

```
val adam = Person("Adam").apply { 
    age = 20                       // 和 this.age = 20 或者 adam.age = 20 一样
    city = "London"
}
println(adam)
```

###### it

反过来，`let` 及 `also` 将上下文对象作为 lambda 表达式参数。如果没有指定参数名，对象可以用隐式默认名称 `it` 访问。`it` 比 `this` 简短，带有 `it` 的表达式通常更容易阅读。然而，当调用对象函数或属性时，不能像 `this` 这样隐式地访问对象。因此，当上下文对象在作用域中主要用作函数调用中的参数时，使用 `it` 作为上下文对象会更好。若在代码块中使用多个变量，则 `it` 也更好。

```
fun getRandomInt(): Int {
    return Random.nextInt(100).also {
        writeToLog("getRandomInt() generated value $it")
    }
}

val i = getRandomInt()
```

此外，当将上下文对象作为参数传递时，可以为上下文对象指定在作用域内的自定义名称。

```
fun getRandomInt(): Int {
    return Random.nextInt(100).also { value ->
        writeToLog("getRandomInt() generated value $value")
    }
}

val i = getRandomInt()
```

##### 返回值

根据返回结果，作用域函数可以分为以下两类：

* `apply` 及 `also` 返回上下文对象。
* `let`、`run` 及 `with` 返回 lambda 表达式结果.

这两个选项使你可以根据在代码中的后续操作来选择适当的函数。

##### 上下文对象

`apply` 及 `also` 的返回值是上下文对象本身。因此，它们可以作为辅助步骤包含在调用链中：你可以继续在同一个对象上进行链式函数调用

```
val numberList = mutableListOf<Double>()
numberList.also { println("Populating the list") }
    .apply {
        add(2.71)
        add(3.14)
        add(1.0)
    }
    .also { println("Sorting the list") }
    .sort()
```

它们还可以用在返回上下文对象的函数的 return 语句中。

```
fun getRandomInt(): Int {
    return Random.nextInt(100).also {
        writeToLog("getRandomInt() generated value $it")
    }
}

val i = getRandomInt()
```

##### Lambda 表达式结果

`let`、`run` 及 `with` 返回 lambda 表达式的结果。所以，在需要使用其结果给一个变量赋值，或者在需要对其结果进行链式操作等情况下，可以使用它们。

```
val numbers = mutableListOf("one", "two", "three")
val countEndsWithE = numbers.run { 
    add("four")
    add("five")
    count { it.endsWith("e") } //返回值
}
println("There are $countEndsWithE elements that end with e.")
```

此外，还可以忽略返回值，仅使用作用域函数为变量创建一个临时作用域。

```
val numbers = mutableListOf("one", "two", "three")
with(numbers) {
    val firstItem = first()
    val lastItem = last()        
    println("First item: $firstItem, last item: $lastItem")
}
```

##### 几个函数

###### let

**上下文对象**作为 lambda 表达式的参数（`it`）来访问。**返回值**是 lambda 表达式的结果。

`let` 可用于在调用链的结果上调用一个或多个函数。例如，以下代码打印对集合的两个操作的结果：

```
val numbers = mutableListOf("one", "two", "three", "four", "five")
val resultList = numbers.map { it.length }.filter { it > 3 }
println(resultList)
```

使用 `let`，可以写成这样：

```
val numbers = mutableListOf("one", "two", "three", "four", "five")
numbers.map { it.length }.filter { it > 3 }.let { 
    println(it)
    // 如果需要可以调用更多函数
} 
```

若代码块仅包含以 `it` 作为参数的单个函数，则可以使用方法引用(`::`)代替 lambda 表达式：

```
val numbers = mutableListOf("one", "two", "three", "four", "five")
numbers.map { it.length }.filter { it > 3 }.let(::println)
```

`let` 经常用于仅使用非空值执行代码块。如需对非空对象执行操作，可对其使用安全调用操作符 `?.` 并调用 `let` 在 lambda 表达式中执行操作。

```
val str: String? = "Hello" 
//processNonNullString(str)       // 编译错误：str 可能为空
val length = str?.let { 
    println("let() called on $it")
    processNonNullString(it)      // 编译通过：'it' 在 '?.let { }' 中必不为空
    it.length
}
```

使用 `let` 的另一种情况是引入作用域受限的局部变量以提高代码的可读性。如需为上下文对象定义一个新变量，可提供其名称作为 lambda 表达式参数来替默认的 `it`。

```
val numbers = listOf("one", "two", "three", "four")
val modifiedFirstItem = numbers.first().let { firstItem ->
    println("The first item of the list is '$firstItem'")
    if (firstItem.length >= 5) firstItem else "!" + firstItem + "!"
}.toUpperCase()
println("First item after modifications: '$modifiedFirstItem'")
```

###### `with`

一个非扩展函数：**上下文对象**作为参数传递，但是在 lambda 表达式内部，它可以作为接收者（`this`）使用。 **返回值**是 lambda 表达式结果。

我们建议使用 `with` 来调用上下文对象上的函数，而不使用 lambda 表达式结果。 在代码中，`with` 可以理解为“*对于这个对象，执行以下操作。*”

```
val numbers = mutableListOf("one", "two", "three")
with(numbers) {
    println("'with' is called with argument $this")  //$this = [one, two, three]
    println("It contains $size elements")  //$size=3
}
```

`with` 的另一个使用场景是引入一个辅助对象，其属性或函数将用于计算一个值

```
val numbers = mutableListOf("one", "two", "three")
val firstAndLast = with(numbers) {
    "The first element is ${first()}," +
    " the last element is ${last()}"
}
println(firstAndLast)
```

###### run

**上下文对象** 作为接收者（`this`）来访问。 **返回值** 是 lambda 表达式结果。

`run` 和 `with` 做同样的事情，但是调用方式和 `let` 一样——作为上下文对象的扩展函数.

当 lambda 表达式同时包含对象初始化和返回值的计算时，`run` 很有用。

```
val service = MultiportService("https://example.kotlinlang.org", 80)

val result = service.run {
    port = 8080
    query(prepareRequest() + " to port $port")
}

// 同样的代码如果用 let() 函数来写:
val letResult = service.let {
    it.port = 8080
    it.query(it.prepareRequest() + " to port ${it.port}")
}
```

除了在接收者对象上调用 `run` 之外，还可以将其用作非扩展函数。 非扩展 `run` 可以使你在需要表达式的地方执行一个由多个语句组成的块。

```
val hexNumberRegex = run {
    val digits = "0-9"
    val hexDigits = "A-Fa-f"
    val sign = "+-"

    Regex("[$sign]?[$digits$hexDigits]+")
}

for (match in hexNumberRegex.findAll("+1234 -FFFF not-a-number")) {
    println(match.value)
}
```

###### apply

**上下文对象** 作为接收者（`this`）来访问。 **返回值** 是上下文对象本身

对于不返回值且主要在接收者（`this`）对象的成员上运行的代码块使用 `apply`。`apply` 的常见情况是对象配置。这样的调用可以理解为“*将以下赋值操作应用于对象*”。

```
val adam = Person("Adam").apply {
    age = 32
    city = "London"        
}
println(adam) //
```

将接收者作为返回值，你可以轻松地将 `apply` 包含到调用链中以进行更复杂的处理。

###### `also`

**上下文对象**作为 lambda 表达式的参数（`it`）来访问。 **返回值**是上下文对象本身。

`also` 对于执行一些将上下文对象作为参数的操作很有用。 对于需要引用对象而不是其属性与函数的操作，或者不想屏蔽来自外部作用域的 `this` 引用时，请使用 `also`。

当你在代码中看到 `also` 时，可以将其理解为“*并且用该对象执行以下操作*”。一般用来打日志参数

```
val numbers = mutableListOf("one", "two", "three")
numbers
	.also { println("new one: $it") } //new one: [one, two, three]
	.add("four")
println(numbers) //[one, two, three, four]
```

###### `takeIf` 与 `takeUnless`

除了作用域函数外，标准库还包含函数 `takeIf` 及 `takeUnless`。这俩函数使你可以将对象状态检查嵌入到调用链中。

当以提供的谓词在对象上进行调用时，若该对象与谓词匹配，则 `takeIf` 返回此对象。否则返回 `null`。因此，`takeIf` 是单个对象的过滤函数。反之，`takeUnless`如果不匹配谓词，则返回对象，如果匹配则返回 `null`。该对象作为 lambda 表达式参数（`it`）来访问。

```
val number = nextInt(1, 100)

val evenOrNull = number.takeIf { it % 2 == 0 }?.also { println("evenOrNull:$it") }
val oddOrNull = number.takeUnless { it % 2 == 0 }?.also { println("oddOrNull:$it}") }
println("number: $number, even: $evenOrNull, odd: $oddOrNull")
# 输出
evenOrNull:56
number: 56, even: 56, odd: null
```

当在 `takeIf` 及 `takeUnless` 之后链式调用其他函数，不要忘记执行空检查或安全调用（`?.`），因为他们的返回值是可为空的。

```
val str = "Hello"
val caps = str.takeIf { it.isNotEmpty() }?.toUpperCase()
//val caps = str.takeIf { it.isNotEmpty() }.toUpperCase() // 编译错误
println(caps)
```

`takeIf` 及 `takeUnless` 与作用域函数一起特别有用。 一个很好的例子是用 `let` 链接它们，以便在与给定谓词匹配的对象上运行代码块。 为此，请在对象上调用 `takeIf`，然后通过安全调用（`?.`）调用 `let`。对于与谓词不匹配的对象，`takeIf` 返回 `null`，并且不调用 `let`。

```
fun displaySubstringPosition(input: String, sub: String) {
    input.indexOf(sub).takeIf { it >= 0 }?.let {
        println("The substring $sub is found in $input.")
        println("Its start position is $it.")
    }
}

displaySubstringPosition("010000011", "11")
displaySubstringPosition("010000011", "12")
```

没有标准库函数时，相同的函数看起来是这样的：

```
fun displaySubstringPosition(input: String, sub: String) {
    val index = input.indexOf(sub)
    if (index >= 0) {
        println("The substring $sub is found in $input.")
        println("Its start position is $index.")
    }
}

displaySubstringPosition("010000011", "11")
displaySubstringPosition("010000011", "12")
```

### 泛型

#### 对泛型进行实化

> Kotlin提供了一个内联函数的概念，我们在之前已经学过了这 个知识点。内联函数中的代码会在编译的时候自动被替换到调用它的地方，这样的话也就不存 在什么泛型擦除的问题了，因为代码在编译之后会直接使用实际的类型来替代内联函数中的泛 型声明，其工作原理如图：

![](https://raw.githubusercontent.com/lizhiguo/pic/master/image-20230425154944133.png)

```
inline fun <reified T> getGenericType() = T::class.java

    @Test
    fun 测试泛型(){
        val result1 = getGenericType<String>()
        val result2 = getGenericType<Int>()
        println("result1 is $result1") //result1 is class java.lang.String
        println("result2 is $result2") //result2 is class java.lang.Integer
    }
```

> 实战泛型实例化

```
# 结合Intent一起使用的。比如说启动一个 Activity就可以这么写：
val intent = Intent(context, TestActivity::class.java)
context.startActivity(intent)
```

有没有觉得TestActivity::class.java这样的语法很难受呢？当然，如果在没有更好选择 的情况下，这种写法也是可以忍受的，但是Kotlin的泛型实化功能使得我们拥有了更好的选择。新建一个reified.kt文件，然后在里面编写如下代码：

```
inline fun <reified T> startActivity(context: Context) {
 val intent = Intent(context, T::class.java)
 context.startActivity(intent)
}
```

果我们想要启动TestActivity，只需要这样写就可以了：

```
startActivity<TestActivity>(context)
```

Kotlin将能够识别出指定泛型的实际类型，并启动相应的Activity

不过，现在的startActivity()函数其实还是有问题的，因为通常在启用Activity的时候还可 能会使用Intent附带一些参数，比如下面的写法：

```
val intent = Intent(context, TestActivity::class.java)
intent.putExtra("param1", "data")
intent.putExtra("param2", 123)
context.startActivity(intent)
```

> 而经过刚才的封装之后，我们就无法进行传参了。这个问题也不难解决，只需要借助之前学习的高阶函数就可以轻松搞定。回到 reified.kt文件当中，这里添加一个新的startActivity()函数重载，如下所示：

```
inline fun <reified T> startActivity(context: Context, block: Intent.() -> Unit) {
 val intent = Intent(context, T::class.java)
 intent.block()
 context.startActivity(intent)
}
```

可以看到，这次的startActivity()函数中增加了一个函数类型参数，并且它的函数类型是 定义在Intent类当中的。在创建完Intent的实例之后，随即调用该函数类型参数，并把Intent的 实例传入，这样调用startActivity()函数的时候就可以在Lambda表达式中为Intent传递 参数了，如下所示：

```
startActivity<TestActivity>(context) {
 putExtra("param1", "data")
 putExtra("param2", 123)
}
```

这种启动Activity的代码写起来实在是太舒服了，泛型实化和高阶函数使这种语法结 构成为了可能。

#### 泛型的协变

协变和逆变之前，我们还得先了解一个约定。一个泛型类或者泛型接口中的方法， 它的参数列表是接收数据的地方，因此可以称它为in位置，而它的返回值是输出数据的地方，因 此可以称它为out位置：

![](https://raw.githubusercontent.com/lizhiguo/pic/master/image-20230425160449982.png)

```
# 常规写法
open class Person(val name: String, val age: Int)
class Student(val st: String, name: String, age: Int) : Person(name, age), Study
class Teacher(val vt: String,name: String, age: Int) : Person(name, age)
# 泛型类
class SimpleData<T> {
 private var data: T? = null
 fun set(t: T?) {
 	data = t
 }
 fun get(): T? {
 	return data
 }
}
fun main() {
 val student = Student("Tom", 19)
 val data = SimpleData<Student>()
 data.set(student)
 handleSimpleData(data) // 实际上这行代码会报错，这里假设它能编译通过
 val studentData = data.get()
}
fun handleSimpleData(data: SimpleData<Person>) {
 val teacher = Teacher("Jack", 35)
 data.set(teacher)
}
```

这里我们对SimpleData类进行了改造，在泛型T的声明前面加上了一个out关键字。这就意味 着现在T只能出现在out位置上，而不能出现在in位置上，同时也意味着SimpleData在泛型T上 是协变的。由于泛型T不能出现在in位置上，因此我们也就不能使用set()方法为data参数赋值了，所以这 里改成了使用构造函数的方式来赋值。你可能会说，构造函数中的泛型T不也是在in位置上的 吗？没错，但是由于这里我们使用了val关键字，所以构造函数中的泛型T仍然是只读的，因此 这样写是合法且安全的。另外，即使我们使用了var关键字，但只要给它加上private修饰 符，保证这个泛型T对于外部而言是不可修改的，那么就都是合法的写法。经过了这样的修改之后，下面的代码就可以完美编译通过且没有任何安全隐患了：

```
着SimpleData在泛型T上 是协变的
class SimpleData<out T>(private val data: T?) {
    fun get(): T? {
        return data
    }
}
class FxTest {
    @Test
    fun tt() {
        val student = Student(st = "cc", name = "Tom", age = 19)
        val data = SimpleData<Student>(student)
        handleSimpleData(data) 
        val studentData = data.get()
        println(JSONUtil.toJsonStr(studentData)) //{"st":"cc","name":"Tom","age":19}
        println("==============================")
        val teacher = Teacher(vt = "ee", name = "King", age = 99)
        val td = SimpleData<Teacher>(teacher)
        handleSimpleData(td)
        val teacherData = td.get()
        println(JSONUtil.toJsonStr(teacherData))//{"vt":"ee","name":"King","age":99}
    }
    private fun handleSimpleData(data: SimpleData<Person>) {
        val personData = data.get()
    }
}

```

#### 泛型的逆变

```
interface Transformer<T> {
    fun transform(t: T): String
}
private fun handleTransformer(trans: Transformer<Student>) {
        val student = Student(st = "cc", name = "Tom", age = 19)
        val result = trans.transform(student)
    }
    @Test
    fun `泛型逆变`() {
        val trans = object : Transformer<Person> {
            override fun transform(t: Person): String {
                return "${t.name} ${t.age}"
            }
        }
        handleTransformer(trans) // 这行代码会报错
    }
```

方法中编写了一个Transformer的匿名类实现，并通过 transform()方法将传入的Person对象转换成了一个“姓名+年龄”拼接的字符串。而 handleTransformer()方法接收的是一个Transformer类型的参数，这里在 handleTransformer()方法中创建了一个Student对象，并调用参数的transform()方法 将Student对象转换成一个字符串。这段代码从安全的角度来分析是没有任何问题的，因为Student是Person的子类，使用 Transformer的匿名类实现将Student对象转换成一个字符串也是绝对安全的，并 不存在类型转换的安全隐患。但是实际上，在调用handleTransformer()方法的时候却会提 示语法错误，原因也很简单，Transformer并不是Transformer的子 类型。那么这个时候逆变就可以派上用场了，它就是专门用于处理这种情况的。修改Transformer接 口中的代码，如下所示： 

```
interface Transformer<in T> {
 fun transform(t: T): String
}
```

> 父类泛型对象可以赋值给子类泛型对象，用 in 
>
> 子类泛型对象可以赋值给父类泛型对象，用 out

### 携程

#### 依赖

```
implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core")
```

#### 启动携程

1. runBlocking: T  //runBlocking用于执行携程任务,通常只用于启动最外层携程，用于线程切换到携程
2. lauch: Job //用于执行携程任务
3. async/await: Deferred //用于执行携程任务,并得到执行结果

```
@Test
fun test() = runBlocking {
    val job = launch {
        repeat(1000) {i ->
            println("挂起中 $i ...")
            delay(500L)
        }
    }
    val job2 = async {
        delay(500L)
        return@async "hello"
    }
    println(job2.await())

    delay(1300L)
    println("主函数等待中")
    job.cancel()
//        job.join()
    println("即将完成结束")
}
//输出
挂起中 0 ...
挂起中 1 ...
hello
挂起中 2 ...
挂起中 3 ...
主函数等待中
即将完成结束

// 携程中线程
@Test
fun 线程() = runBlocking {
    val job = launch {
        println("launch..." + Thread.currentThread().name)
    }
    val job2 = async {
        delay(500L)
        println("async..." + Thread.currentThread().name)
        return@async "hello"
    }
    println("JOB2的输出:"+job2.await())
    delay(1300L)
}
//输出
launch...Test worker @coroutine#2
async...Test worker @coroutine#3
JOB2的输出:hello
```

#### suspend

1. suspend,被suspend修饰的函数只能被有suspend修饰的函数调用
2. 因为suspend修饰的函数(或lambda)被编译后会多一个参数类型叫Continuation
3. 携程的异步调用本质上就是一次回调

```
suspend fun getHtml() :String{
    return async {
        URL("http://www.baidu.com").readText()
    }.await()
}
```

#### Channel

> 在2个携程中建立管道通信，下面的例子，一个放数据，一个取数据

```
@Test
    fun channel() = runBlocking {
        val channel = Channel<Int>()
        launch {
            get(channel)
        }
        launch {
            put(channel)

        }
        Unit
    }
    suspend fun get(channel: Channel<Int>) {
        while (true) {
            println(channel.receive())
        }
    }
    suspend fun put(channel: Channel<Int>) {
        var i = 0
        while (true) {
            channel.send(i++)
        }
    }
```



### DSL

```
class Dependency {
    val libraries = ArrayList<String>()
    fun implementation(lib: String) {
        libraries.add(lib)
    }
}

fun dependencies(block: Dependency.() -> Unit): List<String> {
    val dependency = Dependency()
    dependency.block()
    return dependency.libraries
}

fun main(args: Array<String>) {
    val libraries = dependencies {
        implementation("org.slf4j:slf4j-api:1.7.25")
        implementation("com.squareup.retrofit2:converter-gson:2.6.1")
    }
    println(libraries) //[org.slf4j:slf4j-api:1.7.25, com.squareup.retrofit2:converter-gson:2.6.1]
}
```

## 基础语法

### 基础知识

##### 类型

```
#var 可变类型
var age: Int = 18
#val 不可变类型，赋值完不能再赋值
val name: String = "king"
#String?是可以为空
var name2: String? = null
#使用"!!"强制转换String?到String
fun main() {
  name = name2!!
  #把不为空的String赋值给可以把可能为空的String?
  name2 = name
}
fun hello(str: String): String{
    # 字符串模板语法"$变量"
    print("你好啊$str")
    return str
}
```

##### 单例对象

```
# 定义单例对象
object Lhl{
    fun sayFale(msg: String){
        println("我的妈妈$msg")
    }
}
# java调用
Lhl.INSTANCE.sayFale("cissy");
```

##### kotlin调用java的代码

1. java代码(King.java)

	```
	package com.lhl;
	public class King {
	    public static void main(String[] arg){
	        String t = TestKt.hello("king");
	        System.out.println("--------------------");
	        System.out.println(t);
	        System.out.println("....................");
	        Lhl.INSTANCE.sayFale("cissy");
	    }
	}
	```

2. kotlin代码(KotMain)

	```
	package com.lhl
	class KotMain {
	}
	```

3. kotlin代码

	```
	#java的class
	fun testclass(clazz: Class<King>){
	    print(clazz.simpleName)
	}
	#kotlin的class
	fun testKotClass(clazz: KClass<KotMain>){
	    print(clazz.simpleName)
	}
	
	fun main() {
	    #调用java的
	    testclass(King::class.java)
	    #调用kotlin的
	    testKotClass(KotMain::class)
	}
	```

##### Kotlin的Lambda

1. java-Lambda闭包

	```
	public static void main(String[] args) {
	    Thread thread = new Thread(new Runnable() {
	         @Override
	        public void run() {
	                //..
	        }
	    });
	    thread.start();
	}
	```

2. java8-Lambda闭包

	```
	public static void main(String[] args) {
	    Thread thread = new Thread(() -> {
	            //..
	     });
	    thread.start();
	}
	```

3. kotlin-Lambda

	```
	fun main1(){
	    val thread = Thread({ -> Unit })
	    //如果Lambda没有参数,可以省略箭头符号->
	    val thread = Thread({})
	    thread.start()
	    //如果Lambda是函数的最后一个参数，可以将大括号放在小括号外面
	    val thread = Thread(){}
	    //如果函数只有一个参数且这个参数是Lambda，则可以省略小括号
	    val thread = Thread(){}
	}
	```

	Lambda 闭包声明

	```
	//如果Lambda是函数的最后一个参数，可以将大括号放在小括号外面
	fun onlyif(isDebug: Boolean, block: () -> Unit){
	    if (isDebug) block()
	}
	fun main(arg: Array<String>) {
	    onlyif(true){
	        println("xxxx")
	    }
	}
	```

##### 重点: 函数是“一等公民”

> 传递函数，执行函数是使用“()”

```
fun main(arg: Array<String>) {
    val runnable = Runnable {
        println("Runnable::run")
    }
    val function: () -> Unit
    function = runnable::run
    onlyif(true,function)
}
```

##### 类-构造函数-init代码块

> 注意：先执行init，在执行构造函数

```
open class MainActivity(val int: Int){
    // 继承主构造函数
    constructor() : this(5) {
        println("构造函数")
    }
    // 继承父类的构造函数
    constructor() : super(5) {
        println("构造函数")
    }
    //初始化代码块,在构造函数被调用时调用
    init {
        println("构造"+int)
    }
}
fun main() {
    MainActivity()
}
```

##### 伴生对象

```
open class MainActivity(val int: Int){
    //伴生对象,一定在一个类的内部
    companion object{
        fun isEmpty(str: String): Boolean{
            return "" == str
        }
    }
}
### 完成例子
class Single private constructor(){
    companion object {
        fun get(): Single{
            return Holder.instance
        }
    }
    private object Holder{
        val instance = Single()
    }
}
class StringUtils {
    companion object {
        fun isEmpty(str: String): Boolean{
            return "" == str
        }
    }
}
fun main() {
    print(StringUtils.isEmpty("111"))
}
```

>在java中调用
>要是有“Companion”调用

```
boolean empty = MainActivity.Companion.isEmpty("2")
```

#### 动态代理

>代理使用关键字"by"代理,要是本身实现了方法，代理就不使用

```
interface Animal {
   fun bark()
}
class Dog: Animal{
   override fun bark() {
       println("Wang")
   }
}
class Zoo(animal: Animal): Animal by animal{
   override fun bark() {
       println("Zoo")
   }
}

fun main() {
   Zoo(Dog()).bark()
}
```

### kotlin业务实战

##### 函数实战

```
# 添加一个泛型扩展函数,用来判断数据是否为空字符串
fun <T> T.notBlankXX(): T? {
	if (this.toString().isNotBlank()) {
		return this
	}
	return null
}
# 扩展函数泛型转换成String,只对String类型有效，解决jpa动态条件查询，配合run函数使用
fun String.notBlankXX(): String? {
	if (this.isNotBlank()) {
		return this
	}
	return null
}
# 使用，结合jpa查询中，如果所传数据为空字符串时使用
@Test
fun 测试不为空条件(){
	var a: String? = ""
	a?.notBlankXX()?.let {
		println(it)
	}
}
# 添加泛型扩展函数,参考run函数
fun <R> String.notBlankFinal(block: String.() -> R): R? {
	if (this.isNotBlank()) {
		return block()
	}
	return null
}
# JPA查询例子
@Test
fun DSL查询数据() {
	val vo = PersonVO(username = "",deptName = "hello",age = 12)
	queryFactory.listQuery {
		select(entity(Person::class))
		from(entity(Person::class))
		whereAnd(
			vo?.username?.notBlankXX()?.run { col(Person::username).like("%${this}%") },//为空字符串就不添加
			vo?.username?.notBlankFinal{ col(Person::username).like("%${this}%") },// 使用扩展函数,为空和空字符不添加
			vo?.deptName?.notBlankXX()?.run { col(Person::deptName).equal(this) },
			vo?.age?.run { col(Person::age).between(20,100) })
	}.takeIf { it.isNotEmpty() }?.let {
		println("-----------------------------")
		personMapper.toDto(it.first()!!)
	}?: {log.debug("没找到数据")}
}
# 注意vo?.username?.notBlankXX()?还可以使用kotlin本身函数搞定
vo?.username?.takeIf { it.isNotBlank() }?.run { col(Person::username).like("%${this}%") }


```

##### 委托代理实战

```
interface PersonManager {
    fun create(vo: PersonVO?): PersonDto?
    fun update(id: Long,vo: PersonVO): PersonDto?
    fun findAll(vo: PersonVO): List<PersonDto>?
    fun findOne(id: Long): PersonDto?
}

@Component
@Slf4j
open class PersonManagerImpl(
    private val queryFactory: SpringDataQueryFactory,
    private val personRepository: PersonRepository,
    private val personMapper: PersonMapper
): PersonManager {
    /**
     * 保存数据
     */
    override fun create(vo: PersonVO?): PersonDto? {
        return vo?.let {
            log.debug("-----------------------")
            personMapper.votoEntity(vo)
        }?.let {
            log.debug("-----------------------")
            personRepository.save(it)
        }?.let {
            log.debug("-----------------------")
            personMapper.toDto(it)
        }
    }

    /**
     * 根据ID跟新数据
     */
    @Throws(UnknownException::class)
    override fun update(id: Long,vo: PersonVO): PersonDto? {
        return personRepository.findById(id).map { x->
            with(x) {
                age = vo.age
                username = vo.username
                deptName = vo.deptName
            }
            personRepository.save(x)?.let {
                personMapper.toDto(it)
            }
        }.orElseThrow{ UnknownException() }
//            .orElse(ResponseEntity.notFound().build())
    }
    override fun findAll(vo: PersonVO): List<PersonDto>? {
        return queryFactory.listQuery<Person> {
            select(entity(Person::class))
            from(entity(Person::class))
            where(
                and(
                    vo?.username?.run { col(Person::username).equal(this)},
                    vo?.deptName?.run { col(Person::deptName).equal(this)},
                    vo?.age?.run { col(Person::age).equal(this)}
                )
            )
        }?.let {
            personMapper.toDto(it)
        }
    }
    @Throws(UnknownException::class)
    override fun findOne(id: Long): PersonDto? {
        return personRepository.findById(id).map { x->
            personMapper.toDto(x)
        }.orElseThrow{ UnknownException() }
    }

    @HibernateEventListener
    fun handlePostLoad(entity: Person, event: PostLoadEvent){
        log.debug("<<<<<-----Person----handlePostLoad--------->>>>>>>>>>")
        log.debug(JSONUtil.toJsonPrettyStr(entity))
    }

    @HibernateEventListener
    fun handlePostInsert(entity: Person, event: PostInsertEvent){
        log.debug("-----Person----handlePostInsert---------")
        log.debug(JSONUtil.toJsonPrettyStr(entity))
    }
}
###################service==========================
interface PersonService {
    fun create(vo: PersonVO?): PersonDto?
    fun update(id: Long,vo: PersonVO): PersonDto?
    fun findAll(vo: PersonVO): List<PersonDto>?
    fun findOne(id: Long): PersonDto?
}

/**
 * PersonServiceImpl类实现了PersonService接口，并注入了personManager对象,并使用PersonManager的代理对象,只有接口才能被代理，注意:使用@Qualifier("personServiceImpl")的时候会报错，因为PersonServiceImpl类本身就是依赖PersonManager对象的
 */
@Service
@Transactional
class PersonServiceImpl(@Qualifier("personManagerImpl") val personManager: PersonManager) : PersonService, PersonManager by personManager{}
```



# elasticsearch

## Elasticsearch查询技巧

### 匹配多个词语

使用 bool 查询和 must 子句可以匹配多个词语。例如，匹配同时包含“apple”和“banana”的文档：

```
{
  "query": {
    "bool": {
      "must": [
        { "match": { "text": "apple" }},
        { "match": { "text": "banana" }}
      ]
    }
  }
}
```

### 匹配某个字段中的任意一个词

使用 terms 查询和字段名可以匹配某个字段中的任意一个词。例如，匹配 title 字段中包含“apple”或“banana”的文档：

```
{
  "query": {
    "terms": {
      "title": ["apple", "banana"]
    }
  }
}
```

### 匹配某个字段中的词语前缀

使用 prefix 查询和字段名可以匹配某个字段中的词语前缀。例如，匹配 title 字段中以“app”开头的文档

```
{
  "query": {
    "prefix": {
      "title": "app"
    }
  }
}
```

### 匹配某个字段中的词语通配符

使用 wildcard 查询和字段名可以匹配某个字段中的词语通配符。例如，匹配 title 字段中包含“app”或“ban”的文档：

```
{
  "query": {
    "wildcard": {
      "title": "*app* OR ban*"
    }
  }
}
```

### 匹配某个字段中的词语模糊匹配

使用 fuzzy 查询和字段名可以进行词语模糊匹配。例如，匹配 title 字段中类似于“aple”的文档

```
{
  "query": {
    "fuzzy": {
      "title": "aple"
    }
  }
}
```

#### 匹配某个字段中的词语范围

使用 range 查询和字段名可以匹配某个字段中的词语范围。例如，匹配 price 字段在 10 到 100 之间的文档：

```
{
  "query": {
    "range": {
      "price": {
        "gte": 10,
        "lte": 100
      }
    }
  }
}
```

### 匹配某个字段中的词语存在与否

使用 exists 查询和字段名可以匹配某个字段中的词语是否存在。例如，匹配包含 description 字段的文档

```
{
  "query": {
    "exists": {
      "field": "description"
    }
  }
}
```

### 按照某个字段排序

使用 sort 参数可以按照某个字段进行排序。例如，按照 score 字段从高到低排序

```
{
  "query": {
    "match_all": {}
  },
  "sort": [
    { "score": "desc" }
  ]
}
```

### 返回某些字段的部分数据

使用_source 参数可以返回某些字段的部分数据。例如，只返回 title 和 price 字段的数据

```
{
  "query": {
    "match_all": {}
  },
  "_source": ["title", "price"]
}
```

### 进行分页操作

使用 from 和 size 参数可以进行分页操作。例如，返回第 11-20 条数据

```
{
  "query": {
    "match_all": {}
  },
  "from": 10,
  "size": 10
}
```

### 实战

1. 检索和过滤,检索标题有"好人”,并且id大于0

	1. gt: 大于

	2. gte: 大于等于

	3. lt: 小于

	4. lte: 小于等于

		```
		GET /goods/_search
		{
		  "query": {
		    "bool": {
		      "must": {
		        "match": {
		          "title": {
		            "query": "好人"
		          }
		        }
		      },
		      "filter": {
		        "range": {
		          "id": {
		            "gte": 0
		          }
		        }
		      }
		    }
		  }
		}
		```

2. 检索标题中有"好人"或者"中国人"的文字

	```
	GET /goods/_search
	{
	  "query": {
	    "match": {
	      "title": {
	        "query": "好人 中国人"
	      }
	    }
	  }
	}
	```

3. and查询,检索remake中有"中国"和"起来"，并且title有”好人“

	```
	GET /goods/_search
	{
	  "query": {
	    "bool": {
	      "must": [
	        {
	          "match": {
	            "remake": {
	              "query": "中国"
	            }
	          }
	        },{
	          "match": {
	            "remake": {
	              "query": "站起"
	            }
	          }
	        },{
	          "match": {
	            "title": {
	              "query": "好人"
	            }
	          }
	        }
	      ]
	    }
	  }
	}
	```

#### 查询对照

1. match(全文搜索)
2. match_phrase:短语搜索(完全匹配)

#### 分词解析

1. IK提供了两个分词算法:ik_smart和ik_max_word
2. 其中ik_smart为最少切分,ik_max_word为最细粒度划分

##### 分词解析-smart

```
GET /goods/_analyze
{
  "tokenizer": "ik_smart",
  "text": "但是当然欢迎拉取请求"
}
# 返回数据
{
  "tokens": [
    {
      "token": "但是",
      "start_offset": 0,
      "end_offset": 2,
      "type": "CN_WORD",
      "position": 0
    },
    {
      "token": "当然",
      "start_offset": 2,
      "end_offset": 4,
      "type": "CN_WORD",
      "position": 1
    },
    {
      "token": "欢迎",
      "start_offset": 4,
      "end_offset": 6,
      "type": "CN_WORD",
      "position": 2
    },
    {
      "token": "拉",
      "start_offset": 6,
      "end_offset": 7,
      "type": "CN_CHAR",
      "position": 3
    },
    {
      "token": "取",
      "start_offset": 7,
      "end_offset": 8,
      "type": "CN_CHAR",
      "position": 4
    },
    {
      "token": "请求",
      "start_offset": 8,
      "end_offset": 10,
      "type": "CN_WORD",
      "position": 5
    }
  ]
}
```

##### 分词解析-ik_max_word

```
GET /goods/_analyze
{
  "tokenizer": "ik_max_word",
  "text": "但是当然欢迎拉取请求"
}
# 返回
{
  "tokens": [
    {
      "token": "但是",
      "start_offset": 0,
      "end_offset": 2,
      "type": "CN_WORD",
      "position": 0
    },
    {
      "token": "当然",
      "start_offset": 2,
      "end_offset": 4,
      "type": "CN_WORD",
      "position": 1
    },
    {
      "token": "欢迎",
      "start_offset": 4,
      "end_offset": 6,
      "type": "CN_WORD",
      "position": 2
    },
    {
      "token": "拉",
      "start_offset": 6,
      "end_offset": 7,
      "type": "CN_CHAR",
      "position": 3
    },
    {
      "token": "取",
      "start_offset": 7,
      "end_offset": 8,
      "type": "CN_CHAR",
      "position": 4
    },
    {
      "token": "请求",
      "start_offset": 8,
      "end_offset": 10,
      "type": "CN_WORD",
      "position": 5
    }
  ]
}
```

##### 分词解析-standard

```
GET /goods/_analyze
{
  "tokenizer": "standard",
  "text": "但是当然欢迎拉取请求"
}
# 返回
{
  "tokens": [
    {
      "token": "但",
      "start_offset": 0,
      "end_offset": 1,
      "type": "<IDEOGRAPHIC>",
      "position": 0
    },
    {
      "token": "是",
      "start_offset": 1,
      "end_offset": 2,
      "type": "<IDEOGRAPHIC>",
      "position": 1
    },
    {
      "token": "当",
      "start_offset": 2,
      "end_offset": 3,
      "type": "<IDEOGRAPHIC>",
      "position": 2
    },
    {
      "token": "然",
      "start_offset": 3,
      "end_offset": 4,
      "type": "<IDEOGRAPHIC>",
      "position": 3
    },
    {
      "token": "欢",
      "start_offset": 4,
      "end_offset": 5,
      "type": "<IDEOGRAPHIC>",
      "position": 4
    },
    {
      "token": "迎",
      "start_offset": 5,
      "end_offset": 6,
      "type": "<IDEOGRAPHIC>",
      "position": 5
    },
    {
      "token": "拉",
      "start_offset": 6,
      "end_offset": 7,
      "type": "<IDEOGRAPHIC>",
      "position": 6
    },
    {
      "token": "取",
      "start_offset": 7,
      "end_offset": 8,
      "type": "<IDEOGRAPHIC>",
      "position": 7
    },
    {
      "token": "请",
      "start_offset": 8,
      "end_offset": 9,
      "type": "<IDEOGRAPHIC>",
      "position": 8
    },
    {
      "token": "求",
      "start_offset": 9,
      "end_offset": 10,
      "type": "<IDEOGRAPHIC>",
      "position": 9
    }
  ]
}
```

# Drools

## 基础知识

### 基础语法

```
package rules;
dialect  "mvel"
rule "test"   //rule 关键字,表示规则开始,参数为规则的唯一名称
    attributes   //规则属性,是rule与when之间的参数,为可选项
    when  // 关键字,后面是规则的条件部分
        LHS //left Hand Side, 是规则的条件部分 ,注意如果没有条件，默认是eval(true),默认满足条件,执行结果部分
    then //后面跟规则的结果部分
        RHS //是规则的结果或行为
end      //表示一个规则的结束
```

### 比较操作符

| 符号         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| >            | 大于                                                         |
| <            | 小于                                                         |
| >=           | 大于等于                                                     |
| <=           | 小于等于                                                     |
| ==           | 等于                                                         |
| !=           | 不等                                                         |
| contains     | 检查一个Fact对象的某个属性值是否包含一个指定的对象值         |
| not contains | 检查一个Fact对象的某个属性值是否不包含一个指定的对象值       |
| memberOf     | 判断一个Fact对象的某个属性是否在一个或多个集合中             |
| not memberOf | 判断一个Fact对象的某个属性是否不在一个或多个集合中           |
| matches      | 判断一个Fact对象的属性是否与提供的标准的java正则表达式进行匹配 |
| not matches  | 判断一个Fact对象的属性是否不与提供的标准的java正则表达式进行匹配 |

### attributes使用

#### no-loop 

>true 只匹配一次,也就是只会被执行一次

```
rule "循环"
salience 2
no-loop true
    when
        $cut: Customer(name matches "张.*")
    then
        $cut.name = "张八";
        update($cut);
        System.out.println("888888:" + $cut.getName());
end
# 测试
@Test
fun `属性循环测试`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.insert(Customer(name = "张三"))
    kieSession.fireAllRules()
    kieSession.dispose()
}
```

#### salience

> 规则优先级,数字越大，越优先执行
>
> ```
> 用来设置规则执行的优先级,salience属性的值是一个数字,数字越大执行的优先级越高，默认情况下,规则的salience默认值为0，如果不设置salience属性，规则体的执行顺序为由上到下
> ```

```
rule "r1"
salience 1
    when
    then
        System.out.println("测试Drools===r1");
end

rule "r2"
salience 2
    when
    then
        System.out.println("测试Drools===r2");
end
# 测试
@Test
fun `属性优先级测试`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.fireAllRules()
    kieSession.dispose()
}
#输出
测试Drools===r2
测试Drools===r1

```

#### date-effective

```
rule "时间规则"
date-effective "15-4月-2023" //当前日期不小于2023-04-15时可以执行
    when
    then
        System.out.println("系统当前时间为:"+LocalDateTime.now());
end
# 测试
@Test
fun `属性时间测试`() {
    val kieSession = kieContainer.newKieSession()
    // kieSession.fireAllRules(RuleNameEqualsAgendaFilter("时间规则"))
    kieSession.fireAllRules(RuleNameStartsWithAgendaFilter("启用")) //指定使用那些规则,前缀匹配规则
    kieSession.dispose()
}
```

#### date-expires

```
rule "时间规则2"
date-expires "15-4月-2023" //当前日期不大于2023-04-15时可以执行
    when
    then
        System.out.println("系统当前时间为:"+LocalDateTime.now());
end
# 测试
@Test
fun `属性时间测试`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.fireAllRules(RuleNameEqualsAgendaFilter("时间规则2"))
    kieSession.dispose()
}
```

#### enabled

> 规则是否启用,enabled为true启用，为false不启用

```
rule "启用规则"
enabled false  //true:启用,false:不启用
    when
    then
        System.out.println("系统当前时间为:"+LocalDateTime.now());
end
# 测试
@Test
fun `规则启用`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.fireAllRules(RuleNameEqualsAgendaFilter("启用规则"))
    kieSession.dispose()
}
```

#### dialect

> 方言(dialect)，有2种,mvel和java,默认时java

#### activation-group

> 在一组规则中只有一个被调用

```
rule "att-group-1"
activation-group "t1"
    when
    then
        System.out.println("====:"+LocalDateTime.now());
end
rule "att-group-2"
activation-group "t1"
    when
    then
        System.out.println("系统当前时间为------:"+LocalDateTime.now());
end
# 测试
@Test
fun `规则组使用`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.fireAllRules()
    kieSession.dispose()
}
```

#### agenda-group

> ```
> agenda-group属性,设置焦点才会执行
> ```

```
rule "att-group-1"
agenda-group "001"
    when
    then
        System.out.println("001====:"+LocalDateTime.now());
end
rule "att-group-2"
agenda-group "002"
//auto-focus 自动获得焦点,不用在java调用中设置焦点kieSession.agenda.getAgendaGroup("002").setFocus()
    when
    then
        System.out.println("002------:"+LocalDateTime.now());
end
# 测试
@Test
fun `规则焦点使用`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.agenda.getAgendaGroup("002").setFocus() //设置焦点
    kieSession.fireAllRules()
    kieSession.dispose()
}
```

#### timer

> ```
> 定时器
> ```

```
rule "rule_timer_1"
timer(5s 2s) //5秒后触发,然后每隔2秒触发一次
    when
    then
        System.out.println("规则rule_timer_1触发,触发时间为:"+LocalDateTime.now());
end
rule "rule_timer_2"
timer(cron:0/1 * * * * ?) //每隔1秒触发一次
    when
    then
        System.out.println("规则rule_timer_2触发,触发时间为:"+LocalDateTime.now());
end
# 测试
@Test
@Test
fun `规则定时器使用`() {
    val kieSession = kieContainer.newKieSession()

    // 在kotlin中thread的runnable匿名类实例
    /*Thread(object : Runnable {
        override fun run() {
            kieSession.fireUntilHalt()
        }
    }).start()*/

    // 在kotlin中runnable的lambda表达式
    /*Thread(Runnable {
        run {
            kieSession.fireUntilHalt()
        }
    }).start()*/

    //runnable里面只有一个run方法，可以简化为如下：
    /*Thread(Runnable {
        kieSession.fireUntilHalt()
    }).start()*/

    //Thread里面只有一个Runnable ，我们可以把接口名省略，括号也可以省略
    Thread {
        kieSession.fireUntilHalt()
    }.start()

    Thread.sleep(10000)
    kieSession.halt()
    kieSession.dispose()
}
```

### 工作内存对象操作

1. insert:在drools的工作内存中添加一个对象
2. update: 在drools的工作内存中修改一个对象
3. retract: 在工作内存中移除一个对象

### 常用属性

#### global使用

```
package com.baeldung.drools.rules;

import com.qp.demo.Applicant;

global com.qp.demo.SuggestedRole suggestedRole; //全局变量
global com.qp.demo.DemoService demoService; //spring对象

dialect  "mvel"

rule "Suggest Manager Role"
    when
        Applicant(experienceInYears > 10)
        Applicant(currentSalary > 1000000 && currentSalary <= 2500000)
        eval( "Hello World!2" == demoService.getHello() ) //调用方法返回值
    then
        System.out.println("============="+demoService.getHello());
        suggestedRole.setRole("Manager");
end
# 测试
@Autowired
lateinit var demoService: DemoService
@Test
fun test2() {
    val kieSession = kieContainer.newKieSession()
    val applicant = Applicant("Davis", 37, 1600000.0, 11)
    kieSession.insert(applicant)
    var s = SuggestedRole("")
    kieSession.setGlobal("suggestedRole", s)
    kieSession.setGlobal("demoService", demoService) //spring的service单例对象
    kieSession.fireAllRules()
    kieSession.dispose()
    println(JSONUtil.toJsonPrettyStr(s)) //打印全局变量
}
```

### query

> 内存对象查询

```
//不带参数的查询
//当前query用于查询工作内存中age>30的person对象
query "query-1"
    $person: Person(age > 30)
end

//带有参数的查询
//当前query用于查询工作内存中age>30同时name需要和传递的参数name相同的Person对象
query "query-2"(String nameParam)
    $person: Person(age > 30, name == nameParam)
end
# 测试
@Test
fun `内存对象查询_无参数_测试`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.insert(Person(name = "Jack1", age = 18))
    kieSession.insert(Person(name = "Jack2", age = 60))

    kieSession.fireAllRules()
    //执行查询
    kieSession.getQueryResults("query-1").forEach {
        val p = it.get("${'$'}person") as Person  //kotlin中关键符号'$'转义"${'$'}person" 对应字符"$person",把Row对象转换成person对象,使用as
        println("name:${p.name},age:${p.age}") //输出name:Jack2,age:60
    }

    kieSession.dispose()
}
@Test
fun `内存对象查询_带参数_测试`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.insert(Person(name = "Jack1", age = 18))
    kieSession.insert(Person(name = "Jack2", age = 60))
    kieSession.fireAllRules()
    //执行查询
    kieSession.getQueryResults("query-2","Jack2").forEach {
        val p = it.get("${'$'}person") as Person  //kotlin中关键符号'$'转义"${'$'}person" 对应字符"$person",把Row对象转换成person对象,使用as
        println(p.toString())
    }
    kieSession.dispose()
}
```

### fuction使用

```
function String format(String name){
    return "hello "+ name;
}

rule "function_rule"
    when
        $p: Person(name != null && age > 30)
    then
        String ret = format($p.getName());
        System.out.println(ret);
end
# 测试
@Test
fun `func_测试`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.insert(Person(name = "Jack1", age = 60))
    kieSession.fireAllRules()
    kieSession.dispose()
}
```

### 规则初始化

1. 初始化规则引擎,使用配置文件

2. kmodule.xml

	> 目录：resources/META-INF/kmodule.xml

	```
	<?xml version="1.0" encoding="UTF-8"?>
	<kmodule xmlns="http://www.drools.org/xsd/kmodule">
	    <!-- 这里的packages属性就是规则文件的文件路径 -->
	    <kbase name="myKbase1" packages="rules" default="true">
	        <!-- name:指定ksession名称,可以任意,但是需要唯一
	             default:指定当前session是否为默认
	        -->
	        <ksession name="ksession_rule"  default="true"/>
	    </kbase>
	</kmodule>
	```

	> 使用上面kmodule.xml文件,kieServices.getKieClasspathContainer()

	* Kmodule： 中可以包含一个到多个 kbase,分别对应 drl 的规则文件。
	* Kbase 需要一个唯一的 name,可以取任意字符串。
	* packages： 为drl文件所在resource目录下的路径。注意区分drl文件中的package与此处的package不一定相同。多个包用逗号分隔。默认情况下会扫描 resources目录下所有(包含子目录)规则文件。
	* kbase的default属性：标示当前KieBase是不是默认的,如果是默认的则不用名称 就可以查找到该 KieBase,但每个 module 最多只能有一个默认 - KieBase。
	* kbase的ksession： kbase下面可以有一个或多个 ksession，ksession 的 name 属性必须设置,且必须唯一

3. 代码

	```
	# 第一步,获取服务
	private val kieServices = KieServices.Factory.get()
	# 第二步,获得容器,使用resources/
	val kieClasspathContainer = kieServices.getKieClasspathContainer()
	# 可选,规则文件校验
	// 检查规则文件是否有错
	Results results = kieContainer.verify();
	if (results.hasMessages(Message.Level.ERROR)) {
	    StringBuffer sb = new StringBuffer();
	    for (Message mes : results.getMessages()) {
	        sb.append("解析错误的规则：").append(mes.getPath()).append(" 错误位置：").append(mes.getLine()).append(";");
	    }
	    throw new RuntimeException(sb.toString());
	}
	# 第三步, 通过容器获取规则会话，kiesession
	val kieSession = kieContainer().newKieSession()
	# 第四步,创建时使对象
	val applicant = Applicant("Davis", 37, 1600000.0, 11)
	# 第五步,将事实对象给会话,规则引擎将根据事实对象进行规则匹配
	kieSession.insert(applicant)
	# 第六步,执行规则引擎,触发guiz
	kieSession.fireAllRules()
	# 第七步,关闭会话
	kieSession.dispose()
	```

#### 使用

> 初始化规则引擎,使用代码初始化

```
@Configuration
class DroolsConfiguration {
    companion object {
        private const val RULES_PATH = "rules/"
        private val kieServices = KieServices.Factory.get()
    }
    @Bean
    @ConditionalOnMissingBean
    fun kieFileSystem(): KieFileSystem {
        //添加该设置，导致执行不动
        /*System.setProperties(Properties().apply {
            this.setProperty("drools.dateformat", "yyyy-MM-dd")
        })*/
        return kieServices.newKieFileSystem().apply {
            //加载rules目录下所有规则文件
            PathMatchingResourcePatternResolver().getResources("classpath*:${RULES_PATH}*.*").forEach {
                this.write(ResourceFactory.newClassPathResource("${RULES_PATH}${it.filename}"))
            }
            // 单个加载
//            this.write(ResourceFactory.newClassPathResource("rules/customer-rules3.drl"))
//            this.write(ResourceFactory.newClassPathResource("rules/customer-rules2.drl"))
        }
    }
    @Bean
    @ConditionalOnMissingBean
    fun kieContainer(): KieContainer {
        getKieRepository()
        val kieModule = kieServices.newKieBuilder(kieFileSystem()).buildAll().kieModule
        return kieServices.newKieContainer(kieModule.releaseId)
    }
    @Bean
    @ConditionalOnMissingBean
    fun kieBase(): KieBase {
        return kieContainer().kieBase
    }
    // 使用workbash时，把规则文件上传到maven私服时使用
    fun getKieRepository(){
        val kieRepository = kieServices.repository
        kieRepository.addKieModule { kieRepository.defaultReleaseId }
    }
}
```



## 测试使用

#### 规则测试

```
class DroolsBaseTest {
    val kieContainer = KieServices.Factory.get().let{
        val file = it.newKieFileSystem().apply {
            write(ResourceFactory.newClassPathResource("rules/customer-rules3.drl")) //切换多个规则文件,也就是对单个规则文件测试
        }
        val kieModule = it.newKieBuilder(file).apply {
            this.buildAll()
        }.kieModule
        it.newKieContainer(kieModule.releaseId)
    }
    @Test
    fun `属性优先级测试`() {
        val kieSession = kieContainer.newKieSession()
        kieSession.fireAllRules()
        kieSession.dispose()
    }
}
```

#### drl测试

```
class DroolsBaseTest {
    val kieContainer = KieServices.Factory.get().let{
        val file = it.newKieFileSystem().apply {
            write(ResourceFactory.newClassPathResource("rules/customer-rules8.drl")) //切换多个规则文件,也就是对单个规则文件测试
        }
        val kieModule = it.newKieBuilder(file).apply {
            this.buildAll()
        }.kieModule
        it.newKieContainer(kieModule.releaseId)
    }

    @Test
    fun `属性优先级测试`() {
        val kieSession = kieContainer.newKieSession()
        kieSession.fireAllRules()
        kieSession.dispose()
    }
}
```

#### 根据excel文件生成drl文件

```
class DroolsExcelTest {
    @Test
    fun `决策表测试2`() {
        println("======转换生成决策表==============")
        val inputStream  = ResourceFactory.newClassPathResource("rules/rules1_bak.xls", "UTF-8").inputStream
        val compiler = SpreadsheetCompiler()
        val drl = compiler.compile(inputStream, InputType.XLS)
        println("=======================${drl}=======================")
        val results = KieHelper().addContent(drl, ResourceType.DRL).verify()
        results.getMessages(Message.Level.ERROR).forEach {
            println("错误:${it.text}")
        }
        // 写入文件
        val currentDir = "C:\\mywork\\myDev\\jvmDev\\qpDev\\drools-demo\\src\\main\\resources\\rules"
        val file = File(currentDir, "rules1_bak.drl")
        file.writeText(drl)
    }
    @Test
    fun `决策表测试3`() {
        println("======转换生成决策表==============")
        val inputStream  = ResourceFactory.newClassPathResource("rules/rules2_bak.xls", "UTF-8").inputStream
        val compiler = SpreadsheetCompiler()
        val drl = compiler.compile(inputStream, InputType.XLS)
        println("=======================${drl}=======================")
        val results = KieHelper().addContent(drl, ResourceType.DRL).verify()
        results.getMessages(Message.Level.ERROR).forEach {
            println("错误:${it.text}")
        }
        // 写入文件
        val currentDir = "C:\\mywork\\myDev\\jvmDev\\qpDev\\drools-demo\\src\\main\\resources\\rules"
        val file = File(currentDir, "rules2_bak.drl")
        file.writeText(drl)
    }
}
```

> rules1_bak.xls

| RuleSet             | droolssample                         |                |                       |                           |                                                  |                                                              |             |                  |
| ------------------- | ------------------------------------ | -------------- | --------------------- | ------------------------- | ------------------------------------------------ | ------------------------------------------------------------ | ----------- | ---------------- |
| Import              | com.qp.demo.Apple,com.qp.demo.Person |                |                       |                           |                                                  |                                                              |             |                  |
| Variables           | com.qp.demo.DemoService  demoService |                |                       |                           |                                                  |                                                              |             |                  |
| RuleTable AppleRank |                                      |                |                       |                           |                                                  |                                                              |             |                  |
| NAME                | CONDITION                            | CONDITION      | CONDITION             | ACTION                    | ACTION                                           | ACTION                                                       | DESCRIPTION | ACTIVATION-GROUP |
|                     | $apple:Apple                         | $person:Person |                       |                           |                                                  |                                                              |             |                  |
|                     | eval($param)                         | name  =="$1"   | age >= $1  && age <$2 | $apple.setRank("$param"); | System.out.println("规则:"  + "$1"+ " 执行了."); | System.out.println("规则:"  + drools.getRule().getName() + " 执行了."); |             |                  |
| 规则名              | 大小匹配                             | 姓名匹配       | 年龄匹配              | 执行结果                  | 执行结果                                         | 执行结果                                                     |             |                  |
|                     | size  >= 100                         | 张三           | 0,10                  | S                         | 11                                               | aa                                                           | 1.  规则1   | age-group        |
|                     | 100  > size && size >= 50            | 李四           | 10,20                 | A                         | 22                                               | bb                                                           | 1.  规则2   | age-group        |
|                     | 50  > size && size >= 10             | 张三           | 20,30                 | B                         | 33                                               | vv                                                           | 1.  规则3   | age-group        |
|                     | 10  > size && size >= 5              | 李四           | 30,40                 | C                         | 44                                               | ee                                                           | 1.  规则4   | size-group       |
|                     | 5  > size                            | 张三           | 40,50                 | D                         | 55                                               | kk                                                           | 1.  规则5   | size-group       |
|                     |                                      |                |                       |                           |                                                  |                                                              |             |                  |

> rules2_bak.xls

|                                                              | RuleSet                   | droolssample                         |                       |                           |                                                  |                                                              |             |                  |         |          |
| ------------------------------------------------------------ | ------------------------- | ------------------------------------ | --------------------- | ------------------------- | ------------------------------------------------ | ------------------------------------------------------------ | ----------- | ---------------- | ------- | -------- |
|                                                              | Import                    | com.qp.demo.Apple,com.qp.demo.Person |                       |                           |                                                  |                                                              |             |                  |         |          |
|                                                              | Sequential                | FALSE                                |                       |                           |                                                  |                                                              |             |                  |         |          |
|                                                              | RuleTable apple-rank      |                                      |                       |                           |                                                  |                                                              |             |                  |         |          |
|                                                              | CONDITION                 | CONDITION                            | CONDITION             | ACTION                    | ACTION                                           | ACTION                                                       | DESCRIPTION | ACTIVATION-GROUP | NO-LOOP | PRIORITY |
|                                                              | $apple:Apple              | $person:Person                       |                       |                           |                                                  |                                                              |             |                  |         |          |
|                                                              | eval($param)              | name  =="$1"                         | age >= $1  && age <$2 | $apple.setRank("$param"); | System.out.println("规则:"  + "$1"+ " 执行了."); | System.out.println("规则:"  + drools.getRule().getName() + " 执行了."); |             |                  |         |          |
|                                                              | 大小匹配                  | 姓名匹配                             | 年龄匹配              | 执行结果                  | 执行结果                                         | 执行结果                                                     |             |                  |         |          |
| 规则一：只要名字是张三的，直接判定为 优                      | size >= 100               | 张三                                 | 0,10                  | S,A,B,C,D                 | 11                                               | aa                                                           | 1.  规则1   | age-group        | TRUE    | 99       |
| 规则二：只要名字是李四的，如果分数在0,60之间，直接认为是一般 | 100 > size  && size >= 50 | 李四                                 | 10,20                 | D,C,V                     | 22                                               | bb                                                           | 1.  规则2   | age-group        | FALSE   | 88       |
| 规则三：分数在0,60之间认为是不及格                           | 50 > size  && size >= 10  | 张三                                 | 20,30                 | U,B,S                     | 33                                               | vv                                                           | 1.  规则3   | age-group        | TRUE    | 77       |
| 规则四：分数在60,70之间认为是一般                            | 10 > size  && size >= 5   | 李四                                 | 30,40                 | H,K,T                     | 44                                               | ee                                                           | 1.  规则4   | size-group       | FALSE   | 900      |
| 规则五：分数在70,90之间认为是良好                            | 5 > size                  | 张三                                 | 40,50                 | Y,KL,O                    | 55                                               | kk                                                           | 1.  规则5   | size-group       | TRUE    | 21       |

#### excel文件生成drl文件使用

```
class DroolsExcelDrlTest {
    val kieContainer = KieHelper().apply{
        val inputStream  = ResourceFactory.newClassPathResource("rules/rules1.xls", "UTF-8").inputStream
        val compiler = SpreadsheetCompiler()
        val drl = compiler.compile(inputStream, InputType.XLS)
        addContent(drl, ResourceType.DRL)
    }.kieContainer

    private val apples = listOf(
        Apple(size = 1),
        Apple(size = 5),
        Apple(size = 10),
        Apple(size = 30),
        Apple(size = 70),
        Apple(size = 120)
    )
    @Test
    fun `决策表测试`() {
        val kieSession = kieContainer.newKieSession()
        kieSession?.let {
            apples.forEach { apple ->
                it.insert(apple)
                it.fireAllRules()
                println("Size: ${apple.size} -> Rank: ${apple.rank}")
            }
            it.dispose()
        }
    }
}
```

# DOCKER

## 网络

### 创建网络

```
```

## docker-compose

### 启动

```
docker compose up -d
```

### 卸载

```
docker compose down
```

# GRADLE

#### 依赖

```
dependencies {
    implementation(kotlin("stdlib-jdk8"))

   
// 依赖bom文件,下面就不在需要版本   implementation(enforcedPlatform("${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}"))

    implementation("io.quarkus:quarkus-kotlin")
    implementation("io.quarkus:quarkus-resteasy-reactive")
    implementation("io.quarkus:quarkus-resteasy-reactive-jackson")

    testImplementation("io.quarkus:quarkus-junit5")
    testImplementation("io.rest-assured:rest-assured")
}
```



# Linux

## 常用命令

### vi

```
# 删除文件内容
1. 在按ESC键，在按dd，如要删除多行，5dd，就是删除当前光标到第5行内容
```

### 防火墙

```
开机关闭：systemctl disable firewalld
本次停止：systemctl stop  firewalld
service iptables stop
```

### 安装上传下载

```
yum install lrzsz
```

### 解压

```
tar -zxvf java.tar.gz
解压到指定的文件夹
tar -zxvf java.tar.gz  -C /usr/java
```

### yum

#### yum源理解

yum源仓库的地址 在/etc/yum.repos.d/，并且只能读出第一层的repo文件,yum仓库的文件都是以.repo结尾的

#### 跟新yum

1. 备份原本的仓库文件

	```
	cd /etc/yum.repos.d/ 
	mkdir allbak 
	mv ./* allbak 
	#此时 /etc/yum.repos.d/底下就没有repo文件，此时无法使用yum工具，必须配置yum源，生成新的.repo文件
	```

2. 下载阿里云的.repo仓库文件 ，放到/etc/yum.repos.d/，

	```
	# 下载第一个阿里云仓库文件,-O 参数 ，指定一个下载地址，且改名
	wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
	```

3. epel配置

	```
	# 配置第二个仓库文件 epel 额外仓库（redis，nginx，mongo，ipython）
	wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
	```

4. 清空原本yum缓存

	```
	yum clean all
	```

5. 生成新的阿里云的yum缓存，加速下载预热数据

	```
	yum makecache
	```

### 授权

#### 文件或者文件夹授权

```
# ekp是用户,
chown -R ekp:ekp 文件或者文件夹
# 如给oafile文件夹授权给ekp用户,必须是root用户授权
chown -R ekp:ekp oafile
# 给一个sh文件授权,给任意人员可以执行该文件的权限
chmod -R 777 20230505.sh
```

# python

### 常用功能

1. 天文馆抢票

```
import unittest

from loguru import logger as log
import requests


class MyTestCase(unittest.TestCase):
    def test_something(self):
        kw = {"stadiumId":"69001","reservedate":"2023-05-01","appId":"wx1d7ddce169710ba7"}
        # 设置请求头
        headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36 MicroMessenger/7.0.20.1781(0x6700143B) NetType/WIFI MiniProgramEnv/Windows WindowsWechat/WMPF XWEB/6763",
                   "mpsessid": "DC36471534A7A974359655634C68D6F96747E5E75171771CB8C1AFA7177D3B63@854f0643"}
        url = "https://ticket.sstm.org.cn/vendor/reserve/getReservePeriodListByDate.xhtml"
        # params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()
        response = requests.get(url, params=kw, headers=headers)
        # 查看响应状态码
        print(response.status_code)

        # 查看响应头部字符编码
        print(response.encoding)
        # 查看完整url地址
        print (response.url)
        # 查看响应内容，response.text 返回的是Unicode格式的数据
        print(response.text)
        log.debug(json_data['errcode']) 
        log.debug(json_data['success']) //看是否成功
        if json_data['success'] :
            if json_data['data']['reservePeriodList'][0]['avaiablenum'] > 0:  //看上午是否还有票
                log.debug(json_data['data']['reservePeriodList'][0]['avaiablenum']) //看上午还有几张票

if __name__ == '__main__':
    unittest.main()
```



# 日常问题

## redmine

### 邮件配置

> 在本地添加configuration.yml文件，再把文件拷贝到容器中/usr/src/redmine/config/目录
>
> 1: 拷贝文件,docker cp configuration.yml 98acfc275340:/usr/src/redmine/config/
>
> 2: 进入容器 docker exec -it 98acfc275340 /bin/bash 验证文件是否跟新

```
default:
  email_delivery:
    delivery_method: :smtp
    smtp_settings:
      address: "smtp.qipai.com"
      port: 25
      authentication: :login
      domain: 'qipai.com'
      user_name: 'dev'
      password: 'qipai19799'
      openssl_verify_mode: 'none' #发送邮件时发生错误 (hostname "smtp.qipai.com" does not match the server certificate),添加该属性
```

# 知识归纳

## github

### springboot

#### jackson

##### 动态字段序列化

```
# https://github.com/ksprider/Surgical/tree/master
# https://github.com/shihyuho/jackson-dynamic-filter/tree/master
# https://github.com/shihyuho/jackson-dynamic-filter-spring-boot-starter
```

####  mapstruct

Mapstruct Plus 是 Mapstruct 的增强工具，在 Mapstruct 的基础上，实现了自动生成 Mapper 接口的功能，并强化了部分功能，使 Java 类型转换更加便捷、优雅。

和 Mapstruct 一样，本质上都是一个基于 JSR 269 的 Java 注释处理器，因此可以由 Maven、Gradle、Ant 等来构建触发。

Mapstruct Plus 内嵌 Mapstruct，和 Mapstruct 完全兼容，如果之前已经使用 Mapstruct，可以无缝替换依赖。

```
https://mapstruct.plus/introduction/install.html
```

#### 接口限流

1. 使用百度的ratelimiter-spring-boot-starter

	* **限流维度**为：节点级、方法维度、服务维度限流。
		1. 节点级别含义为限流SDK引入目标服务代码，限流规则针对目标服务部署的每个实例单独生效。
		2. 方法维度含义为可以为目标服务的每个方法单独配置限流规则，该规则针对当前方法生效，与其他方法互不影响，目前方法仅支持HttpMethod+uri。
		3. 服务维度含义为可针对每个服务实例配置全局规则，流入该服务实例的每个请求都将先进行服务限流判断。 服务级和方法级同时存在，将先后进过服务级、方法级两种限流器，任意一个限流器拒绝都将拒绝请求。

	```
	# 依赖
	<dependency>
		<groupId>com.baidubce.formula</groupId>
		<artifactId>ratelimiter-spring-boot-starter</artifactId>
		<version>2.1.1.1</version>
	</dependency>
	```

	应用配置

	```
	spring:
	  application:
	    name: ratelimiter
	---
	formula:
	  ratelimiter:
	    enabled: true
	    ratelimiters:
	    # 限流生效的位置，配置具体的uri
	    - effectiveLocation: /products/q/**
	      # 限流类型：1表示http，2表示rpc(暂未支持)
	      effectiveType: 1
	      # 该规则是否生效
	      enabled: true
	      httpMethod: GET
	      # 限流器类型，1表示令牌桶
	      limiterType: 1
	      # 请求来源，当前版本不区分请求来源，区分请求来源的需求正在开发
	      # source:
	      # 限流的QPS值
	      threshold: 5
	```

	

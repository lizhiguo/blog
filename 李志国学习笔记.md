

# JAVA

## Spring

### SpringBoot

#### Springboot-jpa

##### Junit

> hello

###### Kjpa

# Kotlin

## Kotlin 常用技巧

### kotlin扩展函数

```
# 添加一个泛型扩展函数,用来判断数据是否为空字符串
fun <T> T.notBlankXX(): T? {
	if (this.toString().isNotBlank()) {
		return this
	}
	return null
}
# 扩展函数泛型转换成String,只对String类型有效，解决jpa动态条件查询，配合run函数使用
fun String.notBlankXX(): String? {
	if (this.isNotBlank()) {
		return this
	}
	return null
}
# 使用，结合jpa查询中，如果所传数据为空字符串时使用
@Test
fun 测试不为空条件(){
	var a: String? = ""
	a?.notBlankXX()?.let {
		println(it)
	}
}
# 添加泛型扩展函数,参考run函数
fun <R> String.notBlankFinal(block: String.() -> R): R? {
	if (this.isNotBlank()) {
		return block()
	}
	return null
}
# JPA查询例子
@Test
fun DSL查询数据() {
	val vo = PersonVO(username = "",deptName = "hello",age = 12)
	queryFactory.listQuery {
		select(entity(Person::class))
		from(entity(Person::class))
		whereAnd(
			vo?.username?.notBlankXX()?.run { col(Person::username).like("%${this}%") },//为空字符串就不添加
			vo?.username?.notBlankFinal{ col(Person::username).like("%${this}%") },// 使用扩展函数,为空和空字符不添加
			vo?.deptName?.notBlankXX()?.run { col(Person::deptName).equal(this) },
			vo?.age?.run { col(Person::age).between(20,100) })
	}.takeIf { it.isNotEmpty() }?.let {
		println("-----------------------------")
		personMapper.toDto(it.first()!!)
	}?: {log.debug("没找到数据")}
}

```

# 委托代理

```
interface PersonManager {
    fun create(vo: PersonVO?): PersonDto?
    fun update(id: Long,vo: PersonVO): PersonDto?
    fun findAll(vo: PersonVO): List<PersonDto>?
    fun findOne(id: Long): PersonDto?
}

@Component
@Slf4j
open class PersonManagerImpl(
    private val queryFactory: SpringDataQueryFactory,
    private val personRepository: PersonRepository,
    private val personMapper: PersonMapper
): PersonManager {
    /**
     * 保存数据
     */
    override fun create(vo: PersonVO?): PersonDto? {
        return vo?.let {
            log.debug("-----------------------")
            personMapper.votoEntity(vo)
        }?.let {
            log.debug("-----------------------")
            personRepository.save(it)
        }?.let {
            log.debug("-----------------------")
            personMapper.toDto(it)
        }
    }

    /**
     * 根据ID跟新数据
     */
    @Throws(UnknownException::class)
    override fun update(id: Long,vo: PersonVO): PersonDto? {
        return personRepository.findById(id).map { x->
            with(x) {
                age = vo.age
                username = vo.username
                deptName = vo.deptName
            }
            personRepository.save(x)?.let {
                personMapper.toDto(it)
            }
        }.orElseThrow{ UnknownException() }
//            .orElse(ResponseEntity.notFound().build())
    }
    override fun findAll(vo: PersonVO): List<PersonDto>? {
        return queryFactory.listQuery<Person> {
            select(entity(Person::class))
            from(entity(Person::class))
            where(
                and(
                    vo?.username?.run { col(Person::username).equal(this)},
                    vo?.deptName?.run { col(Person::deptName).equal(this)},
                    vo?.age?.run { col(Person::age).equal(this)}
                )
            )
        }?.let {
            personMapper.toDto(it)
        }
    }
    @Throws(UnknownException::class)
    override fun findOne(id: Long): PersonDto? {
        return personRepository.findById(id).map { x->
            personMapper.toDto(x)
        }.orElseThrow{ UnknownException() }
    }

    @HibernateEventListener
    fun handlePostLoad(entity: Person, event: PostLoadEvent){
        log.debug("<<<<<-----Person----handlePostLoad--------->>>>>>>>>>")
        log.debug(JSONUtil.toJsonPrettyStr(entity))
    }

    @HibernateEventListener
    fun handlePostInsert(entity: Person, event: PostInsertEvent){
        log.debug("-----Person----handlePostInsert---------")
        log.debug(JSONUtil.toJsonPrettyStr(entity))
    }
}
###################service==========================
interface PersonService {
    fun create(vo: PersonVO?): PersonDto?
    fun update(id: Long,vo: PersonVO): PersonDto?
    fun findAll(vo: PersonVO): List<PersonDto>?
    fun findOne(id: Long): PersonDto?
}

/**
 * PersonServiceImpl类实现了PersonService接口，并注入了personManager对象,并使用PersonManager的代理对象,只有接口才能被代理，注意:使用@Qualifier("personServiceImpl")的时候会报错，因为PersonServiceImpl类本身就是依赖PersonManager对象的
 */
@Service
@Transactional
class PersonServiceImpl(@Qualifier("personManagerImpl") val personManager: PersonManager) : PersonService, PersonManager by personManager{}
```

### 泛型

#### 对泛型进行实化

> Kotlin提供了一个内联函数的概念，我们在之前已经学过了这 个知识点。内联函数中的代码会在编译的时候自动被替换到调用它的地方，这样的话也就不存 在什么泛型擦除的问题了，因为代码在编译之后会直接使用实际的类型来替代内联函数中的泛 型声明，其工作原理如图：

![](https://raw.githubusercontent.com/lizhiguo/pic/master/image-20230425154944133.png)

```
inline fun <reified T> getGenericType() = T::class.java

    @Test
    fun 测试泛型(){
        val result1 = getGenericType<String>()
        val result2 = getGenericType<Int>()
        println("result1 is $result1") //result1 is class java.lang.String
        println("result2 is $result2") //result2 is class java.lang.Integer
    }
```

> 实战泛型实例化

```
# 结合Intent一起使用的。比如说启动一个 Activity就可以这么写：
val intent = Intent(context, TestActivity::class.java)
context.startActivity(intent)
```

有没有觉得TestActivity::class.java这样的语法很难受呢？当然，如果在没有更好选择 的情况下，这种写法也是可以忍受的，但是Kotlin的泛型实化功能使得我们拥有了更好的选择。新建一个reified.kt文件，然后在里面编写如下代码：

```
inline fun <reified T> startActivity(context: Context) {
 val intent = Intent(context, T::class.java)
 context.startActivity(intent)
}
```

果我们想要启动TestActivity，只需要这样写就可以了：

```
startActivity<TestActivity>(context)
```

Kotlin将能够识别出指定泛型的实际类型，并启动相应的Activity

不过，现在的startActivity()函数其实还是有问题的，因为通常在启用Activity的时候还可 能会使用Intent附带一些参数，比如下面的写法：

```
val intent = Intent(context, TestActivity::class.java)
intent.putExtra("param1", "data")
intent.putExtra("param2", 123)
context.startActivity(intent)
```

> 而经过刚才的封装之后，我们就无法进行传参了。这个问题也不难解决，只需要借助之前学习的高阶函数就可以轻松搞定。回到 reified.kt文件当中，这里添加一个新的startActivity()函数重载，如下所示：

```
inline fun <reified T> startActivity(context: Context, block: Intent.() -> Unit) {
 val intent = Intent(context, T::class.java)
 intent.block()
 context.startActivity(intent)
}
```

可以看到，这次的startActivity()函数中增加了一个函数类型参数，并且它的函数类型是 定义在Intent类当中的。在创建完Intent的实例之后，随即调用该函数类型参数，并把Intent的 实例传入，这样调用startActivity()函数的时候就可以在Lambda表达式中为Intent传递 参数了，如下所示：

```
startActivity<TestActivity>(context) {
 putExtra("param1", "data")
 putExtra("param2", 123)
}
```

这种启动Activity的代码写起来实在是太舒服了，泛型实化和高阶函数使这种语法结 构成为了可能。

#### 泛型的协变

协变和逆变之前，我们还得先了解一个约定。一个泛型类或者泛型接口中的方法， 它的参数列表是接收数据的地方，因此可以称它为in位置，而它的返回值是输出数据的地方，因 此可以称它为out位置：

![](https://raw.githubusercontent.com/lizhiguo/pic/master/image-20230425160449982.png)

```
# 常规写法
open class Person(val name: String, val age: Int)
class Student(val st: String, name: String, age: Int) : Person(name, age), Study
class Teacher(val vt: String,name: String, age: Int) : Person(name, age)
# 泛型类
class SimpleData<T> {
 private var data: T? = null
 fun set(t: T?) {
 	data = t
 }
 fun get(): T? {
 	return data
 }
}
fun main() {
 val student = Student("Tom", 19)
 val data = SimpleData<Student>()
 data.set(student)
 handleSimpleData(data) // 实际上这行代码会报错，这里假设它能编译通过
 val studentData = data.get()
}
fun handleSimpleData(data: SimpleData<Person>) {
 val teacher = Teacher("Jack", 35)
 data.set(teacher)
}
```

这里我们对SimpleData类进行了改造，在泛型T的声明前面加上了一个out关键字。这就意味 着现在T只能出现在out位置上，而不能出现在in位置上，同时也意味着SimpleData在泛型T上 是协变的。由于泛型T不能出现在in位置上，因此我们也就不能使用set()方法为data参数赋值了，所以这 里改成了使用构造函数的方式来赋值。你可能会说，构造函数中的泛型T不也是在in位置上的 吗？没错，但是由于这里我们使用了val关键字，所以构造函数中的泛型T仍然是只读的，因此 这样写是合法且安全的。另外，即使我们使用了var关键字，但只要给它加上private修饰 符，保证这个泛型T对于外部而言是不可修改的，那么就都是合法的写法。经过了这样的修改之后，下面的代码就可以完美编译通过且没有任何安全隐患了：

```
着SimpleData在泛型T上 是协变的
class SimpleData<out T>(private val data: T?) {
    fun get(): T? {
        return data
    }
}
class FxTest {
    @Test
    fun tt() {
        val student = Student(st = "cc", name = "Tom", age = 19)
        val data = SimpleData<Student>(student)
        handleSimpleData(data) 
        val studentData = data.get()
        println(JSONUtil.toJsonStr(studentData)) //{"st":"cc","name":"Tom","age":19}
        println("==============================")
        val teacher = Teacher(vt = "ee", name = "King", age = 99)
        val td = SimpleData<Teacher>(teacher)
        handleSimpleData(td)
        val teacherData = td.get()
        println(JSONUtil.toJsonStr(teacherData))//{"vt":"ee","name":"King","age":99}
    }
    private fun handleSimpleData(data: SimpleData<Person>) {
        val personData = data.get()
    }
}

```

#### 泛型的逆变

```
interface Transformer<T> {
    fun transform(t: T): String
}
private fun handleTransformer(trans: Transformer<Student>) {
        val student = Student(st = "cc", name = "Tom", age = 19)
        val result = trans.transform(student)
    }
    @Test
    fun `泛型逆变`() {
        val trans = object : Transformer<Person> {
            override fun transform(t: Person): String {
                return "${t.name} ${t.age}"
            }
        }
        handleTransformer(trans) // 这行代码会报错
    }
```

方法中编写了一个Transformer的匿名类实现，并通过 transform()方法将传入的Person对象转换成了一个“姓名+年龄”拼接的字符串。而 handleTransformer()方法接收的是一个Transformer类型的参数，这里在 handleTransformer()方法中创建了一个Student对象，并调用参数的transform()方法 将Student对象转换成一个字符串。这段代码从安全的角度来分析是没有任何问题的，因为Student是Person的子类，使用 Transformer的匿名类实现将Student对象转换成一个字符串也是绝对安全的，并 不存在类型转换的安全隐患。但是实际上，在调用handleTransformer()方法的时候却会提 示语法错误，原因也很简单，Transformer并不是Transformer的子 类型。那么这个时候逆变就可以派上用场了，它就是专门用于处理这种情况的。修改Transformer接 口中的代码，如下所示： 

```
interface Transformer<in T> {
 fun transform(t: T): String
}
```

### DSL

```
class Dependency {
    val libraries = ArrayList<String>()
    fun implementation(lib: String) {
        libraries.add(lib)
    }
}

fun dependencies(block: Dependency.() -> Unit): List<String> {
    val dependency = Dependency()
    dependency.block()
    return dependency.libraries
}

fun main(args: Array<String>) {
    val libraries = dependencies {
        implementation("org.slf4j:slf4j-api:1.7.25")
        implementation("com.squareup.retrofit2:converter-gson:2.6.1")
    }
    println(libraries) //[org.slf4j:slf4j-api:1.7.25, com.squareup.retrofit2:converter-gson:2.6.1]
}
```



## kotlin

### 基础语法

##### 类型

```
#var 可变类型
var age: Int = 18
#val 不可变类型，赋值完不能再赋值
val name: String = "king"
#String?是可以为空
var name2: String? = null
#使用"!!"强制转换String?到String
fun main() {
  name = name2!!
  #把不为空的String赋值给可以把可能为空的String?
  name2 = name
}
fun hello(str: String): String{
    # 字符串模板语法"$变量"
    print("你好啊$str")
    return str
}
```

##### 单例对象

```
# 定义单例对象
object Lhl{
    fun sayFale(msg: String){
        println("我的妈妈$msg")
    }
}
# java调用
Lhl.INSTANCE.sayFale("cissy");
```

##### kotlin调用java的代码

1. java代码(King.java)

	```
	package com.lhl;
	public class King {
	    public static void main(String[] arg){
	        String t = TestKt.hello("king");
	        System.out.println("--------------------");
	        System.out.println(t);
	        System.out.println("....................");
	        Lhl.INSTANCE.sayFale("cissy");
	    }
	}
	```

2. kotlin代码(KotMain)

	```
	package com.lhl
	class KotMain {
	}
	```

3. kotlin代码

	```
	#java的class
	fun testclass(clazz: Class<King>){
	    print(clazz.simpleName)
	}
	#kotlin的class
	fun testKotClass(clazz: KClass<KotMain>){
	    print(clazz.simpleName)
	}
	
	fun main() {
	    #调用java的
	    testclass(King::class.java)
	    #调用kotlin的
	    testKotClass(KotMain::class)
	}
	```

##### Kotlin的Lambda

1. java-Lambda闭包

	```
	public static void main(String[] args) {
	    Thread thread = new Thread(new Runnable() {
	         @Override
	        public void run() {
	                //..
	        }
	    });
	    thread.start();
	}
	```

2. java8-Lambda闭包

	```
	public static void main(String[] args) {
	    Thread thread = new Thread(() -> {
	            //..
	     });
	    thread.start();
	}
	```

3. kotlin-Lambda

	```
	fun main1(){
	    val thread = Thread({ -> Unit })
	    //如果Lambda没有参数,可以省略箭头符号->
	    val thread = Thread({})
	    thread.start()
	    //如果Lambda是函数的最后一个参数，可以将大括号放在小括号外面
	    val thread = Thread(){}
	    //如果函数只有一个参数且这个参数是Lambda，则可以省略小括号
	    val thread = Thread(){}
	}
	```

	Lambda 闭包声明

	```
	//如果Lambda是函数的最后一个参数，可以将大括号放在小括号外面
	fun onlyif(isDebug: Boolean, block: () -> Unit){
	    if (isDebug) block()
	}
	fun main(arg: Array<String>) {
	    onlyif(true){
	        println("xxxx")
	    }
	}
	```

##### 重点: 函数是“一等公民”

> 传递函数，执行函数是使用“()”

```
fun main(arg: Array<String>) {
    val runnable = Runnable {
        println("Runnable::run")
    }
    val function: () -> Unit
    function = runnable::run
    onlyif(true,function)
}
```

##### 类-构造函数-init代码块

> 注意：先执行init，在执行构造函数

```
open class MainActivity(val int: Int){
    // 继承主构造函数
    constructor() : this(5) {
        println("构造函数")
    }
    // 继承父类的构造函数
    constructor() : super(5) {
        println("构造函数")
    }
    //初始化代码块,在构造函数被调用时调用
    init {
        println("构造"+int)
    }
}
fun main() {
    MainActivity()
}
```

##### 伴生对象

```
open class MainActivity(val int: Int){
    //伴生对象,一定在一个类的内部
    companion object{
        fun isEmpty(str: String): Boolean{
            return "" == str
        }
    }
}
### 完成例子
class Single private constructor(){
    companion object {
        fun get(): Single{
            return Holder.instance
        }
    }
    private object Holder{
        val instance = Single()
    }
}
class StringUtils {
    companion object {
        fun isEmpty(str: String): Boolean{
            return "" == str
        }
    }
}
fun main() {
    print(StringUtils.isEmpty("111"))
}
```

>在java中调用
>要是有“Companion”调用

```
boolean empty = MainActivity.Companion.isEmpty("2")
```

#### 动态代理

>代理使用关键字"by"代理,要是本身实现了方法，代理就不使用

```
interface Animal {
   fun bark()
}
class Dog: Animal{
   override fun bark() {
       println("Wang")
   }
}
class Zoo(animal: Animal): Animal by animal{
   override fun bark() {
       println("Zoo")
   }
}

fun main() {
   Zoo(Dog()).bark()
}
```

# Drools

## 基础知识

### 基础语法

```
package rules;
dialect  "mvel"
rule "test"   //rule 关键字,表示规则开始,参数为规则的唯一名称
    attributes   //规则属性,是rule与when之间的参数,为可选项
    when  // 关键字,后面是规则的条件部分
        LHS //left Hand Side, 是规则的条件部分 ,注意如果没有条件，默认是eval(true),默认满足条件,执行结果部分
    then //后面跟规则的结果部分
        RHS //是规则的结果或行为
end      //表示一个规则的结束
```

### 比较操作符

| 符号         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| >            | 大于                                                         |
| <            | 小于                                                         |
| >=           | 大于等于                                                     |
| <=           | 小于等于                                                     |
| ==           | 等于                                                         |
| !=           | 不等                                                         |
| contains     | 检查一个Fact对象的某个属性值是否包含一个指定的对象值         |
| not contains | 检查一个Fact对象的某个属性值是否不包含一个指定的对象值       |
| memberOf     | 判断一个Fact对象的某个属性是否在一个或多个集合中             |
| not memberOf | 判断一个Fact对象的某个属性是否不在一个或多个集合中           |
| matches      | 判断一个Fact对象的属性是否与提供的标准的java正则表达式进行匹配 |
| not matches  | 判断一个Fact对象的属性是否不与提供的标准的java正则表达式进行匹配 |

### attributes使用

#### no-loop 

>true 只匹配一次,也就是只会被执行一次

```
rule "循环"
salience 2
no-loop true
    when
        $cut: Customer(name matches "张.*")
    then
        $cut.name = "张八";
        update($cut);
        System.out.println("888888:" + $cut.getName());
end
# 测试
@Test
fun `属性循环测试`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.insert(Customer(name = "张三"))
    kieSession.fireAllRules()
    kieSession.dispose()
}
```

#### salience

> 规则优先级,数字越大，越优先执行
>
> ```
> 用来设置规则执行的优先级,salience属性的值是一个数字,数字越大执行的优先级越高，默认情况下,规则的salience默认值为0，如果不设置salience属性，规则体的执行顺序为由上到下
> ```

```
rule "r1"
salience 1
    when
    then
        System.out.println("测试Drools===r1");
end

rule "r2"
salience 2
    when
    then
        System.out.println("测试Drools===r2");
end
# 测试
@Test
fun `属性优先级测试`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.fireAllRules()
    kieSession.dispose()
}
#输出
测试Drools===r2
测试Drools===r1

```

#### date-effective

```
rule "时间规则"
date-effective "15-4月-2023" //当前日期不小于2023-04-15时可以执行
    when
    then
        System.out.println("系统当前时间为:"+LocalDateTime.now());
end
# 测试
@Test
fun `属性时间测试`() {
    val kieSession = kieContainer.newKieSession()
    // kieSession.fireAllRules(RuleNameEqualsAgendaFilter("时间规则"))
    kieSession.fireAllRules(RuleNameStartsWithAgendaFilter("启用")) //指定使用那些规则,前缀匹配规则
    kieSession.dispose()
}
```

#### date-expires

```
rule "时间规则2"
date-expires "15-4月-2023" //当前日期不大于2023-04-15时可以执行
    when
    then
        System.out.println("系统当前时间为:"+LocalDateTime.now());
end
# 测试
@Test
fun `属性时间测试`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.fireAllRules(RuleNameEqualsAgendaFilter("时间规则2"))
    kieSession.dispose()
}
```

#### enabled

> 规则是否启用,enabled为true启用，为false不启用

```
rule "启用规则"
enabled false  //true:启用,false:不启用
    when
    then
        System.out.println("系统当前时间为:"+LocalDateTime.now());
end
# 测试
@Test
fun `规则启用`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.fireAllRules(RuleNameEqualsAgendaFilter("启用规则"))
    kieSession.dispose()
}
```

#### dialect

> 方言(dialect)，有2种,mvel和java,默认时java

#### activation-group

> 在一组规则中只有一个被调用

```
rule "att-group-1"
activation-group "t1"
    when
    then
        System.out.println("====:"+LocalDateTime.now());
end
rule "att-group-2"
activation-group "t1"
    when
    then
        System.out.println("系统当前时间为------:"+LocalDateTime.now());
end
# 测试
@Test
fun `规则组使用`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.fireAllRules()
    kieSession.dispose()
}
```

#### agenda-group

> ```
> agenda-group属性,设置焦点才会执行
> ```

```
rule "att-group-1"
agenda-group "001"
    when
    then
        System.out.println("001====:"+LocalDateTime.now());
end
rule "att-group-2"
agenda-group "002"
//auto-focus 自动获得焦点,不用在java调用中设置焦点kieSession.agenda.getAgendaGroup("002").setFocus()
    when
    then
        System.out.println("002------:"+LocalDateTime.now());
end
# 测试
@Test
fun `规则焦点使用`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.agenda.getAgendaGroup("002").setFocus() //设置焦点
    kieSession.fireAllRules()
    kieSession.dispose()
}
```

#### timer

> ```
> 定时器
> ```

```
rule "rule_timer_1"
timer(5s 2s) //5秒后触发,然后每隔2秒触发一次
    when
    then
        System.out.println("规则rule_timer_1触发,触发时间为:"+LocalDateTime.now());
end
rule "rule_timer_2"
timer(cron:0/1 * * * * ?) //每隔1秒触发一次
    when
    then
        System.out.println("规则rule_timer_2触发,触发时间为:"+LocalDateTime.now());
end
# 测试
@Test
@Test
fun `规则定时器使用`() {
    val kieSession = kieContainer.newKieSession()

    // 在kotlin中thread的runnable匿名类实例
    /*Thread(object : Runnable {
        override fun run() {
            kieSession.fireUntilHalt()
        }
    }).start()*/

    // 在kotlin中runnable的lambda表达式
    /*Thread(Runnable {
        run {
            kieSession.fireUntilHalt()
        }
    }).start()*/

    //runnable里面只有一个run方法，可以简化为如下：
    /*Thread(Runnable {
        kieSession.fireUntilHalt()
    }).start()*/

    //Thread里面只有一个Runnable ，我们可以把接口名省略，括号也可以省略
    Thread {
        kieSession.fireUntilHalt()
    }.start()

    Thread.sleep(10000)
    kieSession.halt()
    kieSession.dispose()
}
```

### 工作内存对象操作

1. insert:在drools的工作内存中添加一个对象
2. update: 在drools的工作内存中修改一个对象
3. retract: 在工作内存中移除一个对象

### 常用属性

#### global使用

```
package com.baeldung.drools.rules;

import com.qp.demo.Applicant;

global com.qp.demo.SuggestedRole suggestedRole; //全局变量
global com.qp.demo.DemoService demoService; //spring对象

dialect  "mvel"

rule "Suggest Manager Role"
    when
        Applicant(experienceInYears > 10)
        Applicant(currentSalary > 1000000 && currentSalary <= 2500000)
        eval( "Hello World!2" == demoService.getHello() ) //调用方法返回值
    then
        System.out.println("============="+demoService.getHello());
        suggestedRole.setRole("Manager");
end
# 测试
@Autowired
lateinit var demoService: DemoService
@Test
fun test2() {
    val kieSession = kieContainer.newKieSession()
    val applicant = Applicant("Davis", 37, 1600000.0, 11)
    kieSession.insert(applicant)
    var s = SuggestedRole("")
    kieSession.setGlobal("suggestedRole", s)
    kieSession.setGlobal("demoService", demoService) //spring的service单例对象
    kieSession.fireAllRules()
    kieSession.dispose()
    println(JSONUtil.toJsonPrettyStr(s)) //打印全局变量
}
```

### query

> 内存对象查询

```
//不带参数的查询
//当前query用于查询工作内存中age>30的person对象
query "query-1"
    $person: Person(age > 30)
end

//带有参数的查询
//当前query用于查询工作内存中age>30同时name需要和传递的参数name相同的Person对象
query "query-2"(String nameParam)
    $person: Person(age > 30, name == nameParam)
end
# 测试
@Test
fun `内存对象查询_无参数_测试`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.insert(Person(name = "Jack1", age = 18))
    kieSession.insert(Person(name = "Jack2", age = 60))

    kieSession.fireAllRules()
    //执行查询
    kieSession.getQueryResults("query-1").forEach {
        val p = it.get("${'$'}person") as Person  //kotlin中关键符号'$'转义"${'$'}person" 对应字符"$person",把Row对象转换成person对象,使用as
        println("name:${p.name},age:${p.age}") //输出name:Jack2,age:60
    }

    kieSession.dispose()
}
@Test
fun `内存对象查询_带参数_测试`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.insert(Person(name = "Jack1", age = 18))
    kieSession.insert(Person(name = "Jack2", age = 60))
    kieSession.fireAllRules()
    //执行查询
    kieSession.getQueryResults("query-2","Jack2").forEach {
        val p = it.get("${'$'}person") as Person  //kotlin中关键符号'$'转义"${'$'}person" 对应字符"$person",把Row对象转换成person对象,使用as
        println(p.toString())
    }
    kieSession.dispose()
}
```

### fuction使用

```
function String format(String name){
    return "hello "+ name;
}

rule "function_rule"
    when
        $p: Person(name != null && age > 30)
    then
        String ret = format($p.getName());
        System.out.println(ret);
end
# 测试
@Test
fun `func_测试`() {
    val kieSession = kieContainer.newKieSession()
    kieSession.insert(Person(name = "Jack1", age = 60))
    kieSession.fireAllRules()
    kieSession.dispose()
}
```

### 规则初始化

1. 初始化规则引擎,使用配置文件

2. kmodule.xml

	> 目录：resources/META-INF/kmodule.xml

	```
	<?xml version="1.0" encoding="UTF-8"?>
	<kmodule xmlns="http://www.drools.org/xsd/kmodule">
	    <!-- 这里的packages属性就是规则文件的文件路径 -->
	    <kbase name="myKbase1" packages="rules" default="true">
	        <!-- name:指定ksession名称,可以任意,但是需要唯一
	             default:指定当前session是否为默认
	        -->
	        <ksession name="ksession_rule"  default="true"/>
	    </kbase>
	</kmodule>
	```

	> 使用上面kmodule.xml文件,kieServices.getKieClasspathContainer()

	* Kmodule： 中可以包含一个到多个 kbase,分别对应 drl 的规则文件。
	* Kbase 需要一个唯一的 name,可以取任意字符串。
	* packages： 为drl文件所在resource目录下的路径。注意区分drl文件中的package与此处的package不一定相同。多个包用逗号分隔。默认情况下会扫描 resources目录下所有(包含子目录)规则文件。
	* kbase的default属性：标示当前KieBase是不是默认的,如果是默认的则不用名称 就可以查找到该 KieBase,但每个 module 最多只能有一个默认 - KieBase。
	* kbase的ksession： kbase下面可以有一个或多个 ksession，ksession 的 name 属性必须设置,且必须唯一

3. 代码

	```
	# 第一步,获取服务
	private val kieServices = KieServices.Factory.get()
	# 第二步,获得容器,使用resources/
	val kieClasspathContainer = kieServices.getKieClasspathContainer()
	# 可选,规则文件校验
	// 检查规则文件是否有错
	Results results = kieContainer.verify();
	if (results.hasMessages(Message.Level.ERROR)) {
	    StringBuffer sb = new StringBuffer();
	    for (Message mes : results.getMessages()) {
	        sb.append("解析错误的规则：").append(mes.getPath()).append(" 错误位置：").append(mes.getLine()).append(";");
	    }
	    throw new RuntimeException(sb.toString());
	}
	# 第三步, 通过容器获取规则会话，kiesession
	val kieSession = kieContainer().newKieSession()
	# 第四步,创建时使对象
	val applicant = Applicant("Davis", 37, 1600000.0, 11)
	# 第五步,将事实对象给会话,规则引擎将根据事实对象进行规则匹配
	kieSession.insert(applicant)
	# 第六步,执行规则引擎,触发guiz
	kieSession.fireAllRules()
	# 第七步,关闭会话
	kieSession.dispose()
	```

#### 使用

> 初始化规则引擎,使用代码初始化

```
@Configuration
class DroolsConfiguration {
    companion object {
        private const val RULES_PATH = "rules/"
        private val kieServices = KieServices.Factory.get()
    }
    @Bean
    @ConditionalOnMissingBean
    fun kieFileSystem(): KieFileSystem {
        //添加该设置，导致执行不动
        /*System.setProperties(Properties().apply {
            this.setProperty("drools.dateformat", "yyyy-MM-dd")
        })*/
        return kieServices.newKieFileSystem().apply {
            //加载rules目录下所有规则文件
            PathMatchingResourcePatternResolver().getResources("classpath*:${RULES_PATH}*.*").forEach {
                this.write(ResourceFactory.newClassPathResource("${RULES_PATH}${it.filename}"))
            }
            // 单个加载
//            this.write(ResourceFactory.newClassPathResource("rules/customer-rules3.drl"))
//            this.write(ResourceFactory.newClassPathResource("rules/customer-rules2.drl"))
        }
    }
    @Bean
    @ConditionalOnMissingBean
    fun kieContainer(): KieContainer {
        getKieRepository()
        val kieModule = kieServices.newKieBuilder(kieFileSystem()).buildAll().kieModule
        return kieServices.newKieContainer(kieModule.releaseId)
    }
    @Bean
    @ConditionalOnMissingBean
    fun kieBase(): KieBase {
        return kieContainer().kieBase
    }
    // 使用workbash时，把规则文件上传到maven私服时使用
    fun getKieRepository(){
        val kieRepository = kieServices.repository
        kieRepository.addKieModule { kieRepository.defaultReleaseId }
    }
}
```



## 测试使用

#### 规则测试

```
class DroolsBaseTest {
    val kieContainer = KieServices.Factory.get().let{
        val file = it.newKieFileSystem().apply {
            write(ResourceFactory.newClassPathResource("rules/customer-rules3.drl")) //切换多个规则文件,也就是对单个规则文件测试
        }
        val kieModule = it.newKieBuilder(file).apply {
            this.buildAll()
        }.kieModule
        it.newKieContainer(kieModule.releaseId)
    }
    @Test
    fun `属性优先级测试`() {
        val kieSession = kieContainer.newKieSession()
        kieSession.fireAllRules()
        kieSession.dispose()
    }
}
```

#### drl测试

```
class DroolsBaseTest {
    val kieContainer = KieServices.Factory.get().let{
        val file = it.newKieFileSystem().apply {
            write(ResourceFactory.newClassPathResource("rules/customer-rules8.drl")) //切换多个规则文件,也就是对单个规则文件测试
        }
        val kieModule = it.newKieBuilder(file).apply {
            this.buildAll()
        }.kieModule
        it.newKieContainer(kieModule.releaseId)
    }

    @Test
    fun `属性优先级测试`() {
        val kieSession = kieContainer.newKieSession()
        kieSession.fireAllRules()
        kieSession.dispose()
    }
}
```

#### 根据excel文件生成drl文件

```
class DroolsExcelTest {
    @Test
    fun `决策表测试2`() {
        println("======转换生成决策表==============")
        val inputStream  = ResourceFactory.newClassPathResource("rules/rules1_bak.xls", "UTF-8").inputStream
        val compiler = SpreadsheetCompiler()
        val drl = compiler.compile(inputStream, InputType.XLS)
        println("=======================${drl}=======================")
        val results = KieHelper().addContent(drl, ResourceType.DRL).verify()
        results.getMessages(Message.Level.ERROR).forEach {
            println("错误:${it.text}")
        }
        // 写入文件
        val currentDir = "C:\\mywork\\myDev\\jvmDev\\qpDev\\drools-demo\\src\\main\\resources\\rules"
        val file = File(currentDir, "rules1_bak.drl")
        file.writeText(drl)
    }
    @Test
    fun `决策表测试3`() {
        println("======转换生成决策表==============")
        val inputStream  = ResourceFactory.newClassPathResource("rules/rules2_bak.xls", "UTF-8").inputStream
        val compiler = SpreadsheetCompiler()
        val drl = compiler.compile(inputStream, InputType.XLS)
        println("=======================${drl}=======================")
        val results = KieHelper().addContent(drl, ResourceType.DRL).verify()
        results.getMessages(Message.Level.ERROR).forEach {
            println("错误:${it.text}")
        }
        // 写入文件
        val currentDir = "C:\\mywork\\myDev\\jvmDev\\qpDev\\drools-demo\\src\\main\\resources\\rules"
        val file = File(currentDir, "rules2_bak.drl")
        file.writeText(drl)
    }
}
```

> rules1_bak.xls

| RuleSet             | droolssample                         |                |                       |                           |                                                  |                                                              |             |                  |
| ------------------- | ------------------------------------ | -------------- | --------------------- | ------------------------- | ------------------------------------------------ | ------------------------------------------------------------ | ----------- | ---------------- |
| Import              | com.qp.demo.Apple,com.qp.demo.Person |                |                       |                           |                                                  |                                                              |             |                  |
| Variables           | com.qp.demo.DemoService  demoService |                |                       |                           |                                                  |                                                              |             |                  |
| RuleTable AppleRank |                                      |                |                       |                           |                                                  |                                                              |             |                  |
| NAME                | CONDITION                            | CONDITION      | CONDITION             | ACTION                    | ACTION                                           | ACTION                                                       | DESCRIPTION | ACTIVATION-GROUP |
|                     | $apple:Apple                         | $person:Person |                       |                           |                                                  |                                                              |             |                  |
|                     | eval($param)                         | name  =="$1"   | age >= $1  && age <$2 | $apple.setRank("$param"); | System.out.println("规则:"  + "$1"+ " 执行了."); | System.out.println("规则:"  + drools.getRule().getName() + " 执行了."); |             |                  |
| 规则名              | 大小匹配                             | 姓名匹配       | 年龄匹配              | 执行结果                  | 执行结果                                         | 执行结果                                                     |             |                  |
|                     | size  >= 100                         | 张三           | 0,10                  | S                         | 11                                               | aa                                                           | 1.  规则1   | age-group        |
|                     | 100  > size && size >= 50            | 李四           | 10,20                 | A                         | 22                                               | bb                                                           | 1.  规则2   | age-group        |
|                     | 50  > size && size >= 10             | 张三           | 20,30                 | B                         | 33                                               | vv                                                           | 1.  规则3   | age-group        |
|                     | 10  > size && size >= 5              | 李四           | 30,40                 | C                         | 44                                               | ee                                                           | 1.  规则4   | size-group       |
|                     | 5  > size                            | 张三           | 40,50                 | D                         | 55                                               | kk                                                           | 1.  规则5   | size-group       |
|                     |                                      |                |                       |                           |                                                  |                                                              |             |                  |

> rules2_bak.xls

|                                                              | RuleSet                   | droolssample                         |                       |                           |                                                  |                                                              |             |                  |         |          |
| ------------------------------------------------------------ | ------------------------- | ------------------------------------ | --------------------- | ------------------------- | ------------------------------------------------ | ------------------------------------------------------------ | ----------- | ---------------- | ------- | -------- |
|                                                              | Import                    | com.qp.demo.Apple,com.qp.demo.Person |                       |                           |                                                  |                                                              |             |                  |         |          |
|                                                              | Sequential                | FALSE                                |                       |                           |                                                  |                                                              |             |                  |         |          |
|                                                              | RuleTable apple-rank      |                                      |                       |                           |                                                  |                                                              |             |                  |         |          |
|                                                              | CONDITION                 | CONDITION                            | CONDITION             | ACTION                    | ACTION                                           | ACTION                                                       | DESCRIPTION | ACTIVATION-GROUP | NO-LOOP | PRIORITY |
|                                                              | $apple:Apple              | $person:Person                       |                       |                           |                                                  |                                                              |             |                  |         |          |
|                                                              | eval($param)              | name  =="$1"                         | age >= $1  && age <$2 | $apple.setRank("$param"); | System.out.println("规则:"  + "$1"+ " 执行了."); | System.out.println("规则:"  + drools.getRule().getName() + " 执行了."); |             |                  |         |          |
|                                                              | 大小匹配                  | 姓名匹配                             | 年龄匹配              | 执行结果                  | 执行结果                                         | 执行结果                                                     |             |                  |         |          |
| 规则一：只要名字是张三的，直接判定为 优                      | size >= 100               | 张三                                 | 0,10                  | S,A,B,C,D                 | 11                                               | aa                                                           | 1.  规则1   | age-group        | TRUE    | 99       |
| 规则二：只要名字是李四的，如果分数在0,60之间，直接认为是一般 | 100 > size  && size >= 50 | 李四                                 | 10,20                 | D,C,V                     | 22                                               | bb                                                           | 1.  规则2   | age-group        | FALSE   | 88       |
| 规则三：分数在0,60之间认为是不及格                           | 50 > size  && size >= 10  | 张三                                 | 20,30                 | U,B,S                     | 33                                               | vv                                                           | 1.  规则3   | age-group        | TRUE    | 77       |
| 规则四：分数在60,70之间认为是一般                            | 10 > size  && size >= 5   | 李四                                 | 30,40                 | H,K,T                     | 44                                               | ee                                                           | 1.  规则4   | size-group       | FALSE   | 900      |
| 规则五：分数在70,90之间认为是良好                            | 5 > size                  | 张三                                 | 40,50                 | Y,KL,O                    | 55                                               | kk                                                           | 1.  规则5   | size-group       | TRUE    | 21       |

#### excel文件生成drl文件使用

```
class DroolsExcelDrlTest {
    val kieContainer = KieHelper().apply{
        val inputStream  = ResourceFactory.newClassPathResource("rules/rules1.xls", "UTF-8").inputStream
        val compiler = SpreadsheetCompiler()
        val drl = compiler.compile(inputStream, InputType.XLS)
        addContent(drl, ResourceType.DRL)
    }.kieContainer

    private val apples = listOf(
        Apple(size = 1),
        Apple(size = 5),
        Apple(size = 10),
        Apple(size = 30),
        Apple(size = 70),
        Apple(size = 120)
    )
    @Test
    fun `决策表测试`() {
        val kieSession = kieContainer.newKieSession()
        kieSession?.let {
            apples.forEach { apple ->
                it.insert(apple)
                it.fireAllRules()
                println("Size: ${apple.size} -> Rank: ${apple.rank}")
            }
            it.dispose()
        }
    }
}
```



# 日常问题

## redmine

### 邮件配置

> 在本地添加configuration.yml文件，再把文件拷贝到容器中/usr/src/redmine/config/目录
>
> 1: 拷贝文件,docker cp configuration.yml 98acfc275340:/usr/src/redmine/config/
>
> 2: 进入容器 docker exec -it 98acfc275340 /bin/bash 验证文件是否跟新

```
default:
  email_delivery:
    delivery_method: :smtp
    smtp_settings:
      address: "smtp.qipai.com"
      port: 25
      authentication: :login
      domain: 'qipai.com'
      user_name: 'dev'
      password: 'qipai19799'
      openssl_verify_mode: 'none' #发送邮件时发生错误 (hostname "smtp.qipai.com" does not match the server certificate),添加该属性
```

